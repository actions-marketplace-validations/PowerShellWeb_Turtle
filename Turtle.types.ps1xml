<!-- Generated with EZOut 2.0.6: Install-Module EZOut or https://github.com/StartAutomating/EZOut -->
<Types>
  <Type>
    <Name>Turtle</Name>
    <Members>
      <MemberSet>
        <Name>PSStandardMembers</Name>
        <Members>
          <PropertySet>
            <Name>DefaultDisplayPropertySet</Name>
            <ReferencedProperties>
              <Name>Heading</Name>
              <Name>Position</Name>
            </ReferencedProperties>
          </PropertySet>
        </Members>
      </MemberSet>
      <AliasProperty>
        <Name>a</Name>
        <ReferencedMemberName>Arc</ReferencedMemberName>
      </AliasProperty>
      <AliasProperty>
        <Name>ArcL</Name>
        <ReferencedMemberName>ArcLeft</ReferencedMemberName>
      </AliasProperty>
      <AliasProperty>
        <Name>ArcR</Name>
        <ReferencedMemberName>ArcRight</ReferencedMemberName>
      </AliasProperty>
      <AliasProperty>
        <Name>Back</Name>
        <ReferencedMemberName>Backward</ReferencedMemberName>
      </AliasProperty>
      <AliasProperty>
        <Name>BackgroundColour</Name>
        <ReferencedMemberName>BackgroundColor</ReferencedMemberName>
      </AliasProperty>
      <AliasProperty>
        <Name>BézierCurve</Name>
        <ReferencedMemberName>BezierCurve</ReferencedMemberName>
      </AliasProperty>
      <AliasProperty>
        <Name>bk</Name>
        <ReferencedMemberName>Backward</ReferencedMemberName>
      </AliasProperty>
      <AliasProperty>
        <Name>c</Name>
        <ReferencedMemberName>CubicBezierCurve</ReferencedMemberName>
      </AliasProperty>
      <AliasProperty>
        <Name>CubicBézierCurve</Name>
        <ReferencedMemberName>CubicBezierCurve</ReferencedMemberName>
      </AliasProperty>
      <AliasProperty>
        <Name>Defs</Name>
        <ReferencedMemberName>Defines</ReferencedMemberName>
      </AliasProperty>
      <AliasProperty>
        <Name>down</Name>
        <ReferencedMemberName>PenDown</ReferencedMemberName>
      </AliasProperty>
      <AliasProperty>
        <Name>fd</Name>
        <ReferencedMemberName>Forward</ReferencedMemberName>
      </AliasProperty>
      <AliasProperty>
        <Name>FillColour</Name>
        <ReferencedMemberName>FillColor</ReferencedMemberName>
      </AliasProperty>
      <AliasProperty>
        <Name>FlowerGolden</Name>
        <ReferencedMemberName>GoldenFlower</ReferencedMemberName>
      </AliasProperty>
      <AliasProperty>
        <Name>FlowerStar</Name>
        <ReferencedMemberName>StarFlower</ReferencedMemberName>
      </AliasProperty>
      <AliasProperty>
        <Name>HLineBy</Name>
        <ReferencedMemberName>HorizontalLine</ReferencedMemberName>
      </AliasProperty>
      <AliasProperty>
        <Name>Href</Name>
        <ReferencedMemberName>Link</ReferencedMemberName>
      </AliasProperty>
      <AliasProperty>
        <Name>Keyframes</Name>
        <ReferencedMemberName>Keyframe</ReferencedMemberName>
      </AliasProperty>
      <AliasProperty>
        <Name>l</Name>
        <ReferencedMemberName>Step</ReferencedMemberName>
      </AliasProperty>
      <AliasProperty>
        <Name>LineTo</Name>
        <ReferencedMemberName>GoTo</ReferencedMemberName>
      </AliasProperty>
      <AliasProperty>
        <Name>lt</Name>
        <ReferencedMemberName>Left</ReferencedMemberName>
      </AliasProperty>
      <AliasProperty>
        <Name>MarkerMid</Name>
        <ReferencedMemberName>MarkerMiddle</ReferencedMemberName>
      </AliasProperty>
      <AliasProperty>
        <Name>MoveTo</Name>
        <ReferencedMemberName>Teleport</ReferencedMemberName>
      </AliasProperty>
      <AliasProperty>
        <Name>pd</Name>
        <ReferencedMemberName>PenDown</ReferencedMemberName>
      </AliasProperty>
      <AliasProperty>
        <Name>PenColour</Name>
        <ReferencedMemberName>PenColor</ReferencedMemberName>
      </AliasProperty>
      <AliasProperty>
        <Name>Pie</Name>
        <ReferencedMemberName>PieGraph</ReferencedMemberName>
      </AliasProperty>
      <AliasProperty>
        <Name>pu</Name>
        <ReferencedMemberName>PenUp</ReferencedMemberName>
      </AliasProperty>
      <AliasProperty>
        <Name>q</Name>
        <ReferencedMemberName>QuadraticBezierCurve</ReferencedMemberName>
      </AliasProperty>
      <AliasProperty>
        <Name>QuadraticBézierCurve</Name>
        <ReferencedMemberName>QuadraticBezierCurve</ReferencedMemberName>
      </AliasProperty>
      <AliasProperty>
        <Name>r</Name>
        <ReferencedMemberName>Rotate</ReferencedMemberName>
      </AliasProperty>
      <AliasProperty>
        <Name>rt</Name>
        <ReferencedMemberName>Right</ReferencedMemberName>
      </AliasProperty>
      <AliasProperty>
        <Name>s</Name>
        <ReferencedMemberName>BezierCurve</ReferencedMemberName>
      </AliasProperty>
      <AliasProperty>
        <Name>SetPos</Name>
        <ReferencedMemberName>GoTo</ReferencedMemberName>
      </AliasProperty>
      <AliasProperty>
        <Name>SetPosition</Name>
        <ReferencedMemberName>GoTo</ReferencedMemberName>
      </AliasProperty>
      <AliasProperty>
        <Name>SierpińskiArrowHeadCurve</Name>
        <ReferencedMemberName>SierpinskiArrowHeadCurve</ReferencedMemberName>
      </AliasProperty>
      <AliasProperty>
        <Name>SierpińskiCurve</Name>
        <ReferencedMemberName>SierpinskiCurve</ReferencedMemberName>
      </AliasProperty>
      <AliasProperty>
        <Name>SierpińskiSquareCurve</Name>
        <ReferencedMemberName>SierpinskiSquareCurve</ReferencedMemberName>
      </AliasProperty>
      <AliasProperty>
        <Name>SierpińskiTriangle</Name>
        <ReferencedMemberName>SierpinskiTriangle</ReferencedMemberName>
      </AliasProperty>
      <AliasProperty>
        <Name>Styles</Name>
        <ReferencedMemberName>Style</ReferencedMemberName>
      </AliasProperty>
      <AliasProperty>
        <Name>up</Name>
        <ReferencedMemberName>PenUp</ReferencedMemberName>
      </AliasProperty>
      <AliasProperty>
        <Name>VLineBy</Name>
        <ReferencedMemberName>VerticalLine</ReferencedMemberName>
      </AliasProperty>
      <AliasProperty>
        <Name>xPos</Name>
        <ReferencedMemberName>xcor</ReferencedMemberName>
      </AliasProperty>
      <AliasProperty>
        <Name>yPos</Name>
        <ReferencedMemberName>ycor</ReferencedMemberName>
      </AliasProperty>
      <ScriptMethod>
        <Name>Arc</Name>
        <Script>
                        &lt;#
.SYNOPSIS
    Draws an Arc
.DESCRIPTION
    Draws an arc with the Turtle.
.NOTES
    This method directly corresponds to the `a` instruction in an SVG Path.
.LINK
    https://developer.mozilla.org/en-US/docs/Web/SVG/Tutorials/SVG_from_scratch/Paths#arcs
#&gt;
param(
# The X Radius of the arc.
[double]
$RadiusX,

# The Y Radius of the arc.
[double]
$RadiusY,

# The rotation along the x-axis.
[double]
$Rotation = 0,

# If set to 1, will draw a large arc.
# If set to 0, will draw a small arc
[ValidateSet(0,1, "Large", "Small", $true, $false)]
[PSObject]
$IsLargeArc = 1,

# By default, the arc will be drawn clockwise
# If this is set to 1, the arc will be drawn counterclockwise
# If set to 1, will draw an arc counterclockwise
[ValidateSet(0, 1, 'Clockwise','CounterclockWise', 'cw', 'ccw', $true, $false)]
[PSObject]
$IsCounterClockwise = 0,

# The deltaX 
[double]
$DeltaX,

# The deltaY 
[double]
$DeltaY
)

if ($DeltaX -or $DeltaY) {
    $this.Position = $DeltaX,$DeltaY
    # If the pen is down
    if ($this.IsPenDown) {
        # draw the curve
        $LargeArcFlag = ($IsLargeArc -in 1, 'Large',$true) -as [byte]
        $SweepFlag = ($IsCounterClockwise -in 1, 'ccw','CounterClockwise', $true) -as [byte]
        $this.Steps.Add("a $RadiusX $RadiusY $Rotation $LargeArcFlag $SweepFlag $DeltaX $DeltaY")
    } else {        
        # otherwise, move to the deltaX/deltaY
        $this.Steps.Add("m $deltaX $deltaY")
    }
}

return $this



                    </Script>
      </ScriptMethod>
      <ScriptMethod>
        <Name>ArcLeft</Name>
        <Script>
                        &lt;#
.SYNOPSIS
    Arcs the turtle to the left
.DESCRIPTION
    Arcs the turtle to the left (counter-clockwise) a number of degrees.

    For each degree, the turtle will move forward and rotate.
.NOTES
    The amount moved forward will be the portion of the circumference.
#&gt;
param(
# The radius of a the circle, were it to complete the arc.
[double]
$Radius = 10,

# The angle of the arc
[double]
$Angle = 60
)

# Rather than duplicate logic, we will simply reverse the angle
$angle *= -1
# and arc to the "right".
return $this.ArcRight($Radius, $Angle)
                    </Script>
      </ScriptMethod>
      <ScriptMethod>
        <Name>ArcRight</Name>
        <Script>
                        &lt;#
.SYNOPSIS
    Arcs the turtle to the right
.DESCRIPTION
    Arcs the turtle to the right (clockwise) a number of degrees.

    For each degree, the turtle will move forward and rotate.
.NOTES
    The amount moved forward will be the portion of the circumference.
#&gt;
param(
# The radius of a the circle, were it to complete the arc.
[double]
$Radius = 10,

# The angle of the arc
[double]
$Angle = 60,

# The number of steps.  If not provided, will default to half of the angle.
[int]
$StepCount
)

# Determine the absolute angle, for this operation
$absAngle = [Math]::Abs($angle)

if ($absAngle -eq 0) { return $this }

# Determine the circumference of a circle of this radius
$Circumference = ((2 * $Radius) * [Math]::PI)

# The circumference step is the circumference times 
# the number of revolutions
$revolutionCount = $angle/360
# divided by the angle
$CircumferenceStep = ($Circumference * $revolutionCount) / $Angle

# The iteration is as close to one or negative one as possible
$iteration  = $angle / [Math]::Floor($absAngle)

# If we have no step count
if (-not $StepCount) {
    # default to half of the angle.
    $StepCount = [Math]::Round($absAngle / 2)    
}
# Turn this into a ratio (by default, this ratio would be `2`).
$stepSize = $absAngle / $StepCount

# Starting at zero, keep turning until we have reached the number.
# Increase our angle by iteration * stepSize each time.
for ($angleDelta = 0; [Math]::Abs($angleDelta) -lt $absAngle; $angleDelta+=($iteration*$stepSize)) {    
    $this = $this. # In each step, 
        Forward($CircumferenceStep*$StepSize). # move forward a fraction of the circumference,
        Rotate($iteration*$StepSize) # and rotate a fraction of the total angle.
}

# When we are done, return $this so we never break the chain.
return $this
                    </Script>
      </ScriptMethod>
      <ScriptMethod>
        <Name>Backward</Name>
        <Script>
                        &lt;#
.SYNOPSIS
    Moves backwards
.DESCRIPTION
    Moves the turtle backwards by a specified distance.
.EXAMPLE
    Move-Turtle Forward 10 | 
        Move-Turtle Backward 5 | 
        Move-Turtle Rotate 90 | 
        Move-Turtle Forward 20 | 
        Save-Turtle ./DrawT.svg
#&gt;
param(
# The distance to move backwards
[double]
$Distance = 10
)

$this.Forward($Distance * -1)

                    </Script>
      </ScriptMethod>
      <ScriptMethod>
        <Name>BarGraph</Name>
        <Script>
                        &lt;#
.SYNOPSIS
    Draws a bar graph using turtle graphics.
.DESCRIPTION
    This script uses turtle graphics to draw a bar graph based on the provided data.
.EXAMPLE
    turtle barGraph 100 100 5 10 15 20 15 10 5
.EXAMPLE
    turtle barGraph 200 200 (
        @(1..50;-1..-50) | 
            Get-Random -Count (Get-Random -Minimum 5 -Maximum 20)
    ) save ./RandomBarGraph.svg
.EXAMPLE
    turtle rotate 90 barGraph 200 200 (
        @(1..50;-1..-50) | 
            Get-Random -Count (Get-Random -Minimum 5 -Maximum 20)
    ) save ./RandomVerticalBarGraph.svg
.EXAMPLE
    turtle rotate 45 barGraph 200 200 (
        @(1..50;-1..-50) | 
            Get-Random -Count (Get-Random -Minimum 5 -Maximum 20)
    ) save ./RandomDiagonalBarGraph.svg
.EXAMPLE
    $sourceData = @(1..50;-1..-50)
    $itemCount  = (Get-Random -Minimum 5 -Maximum 20) 
    $points     = $sourceData | Get-Random -Count $itemCount
    turtle bargraph 200 200 $points morph @(
        turtle bargraph 200 200 $points
        turtle bargraph 200 200 ( $sourceData | Get-Random -Count $itemCount )
        turtle bargraph 200 200 $points
    ) save ./RandomBarGraphMorph.svg
#&gt;
param(
# The width of the bar graph
[double]$Width,
# The height of the bar graph.
# Please note that in the case of negative values, the effective height is twice this number.
[double]$Height,

# The points in the bar graph.  
# Each point will be turned into a relative number and turned into an equal-width bar.
[Parameter(ValueFromRemainingArguments)]
[double[]]$Points
)


# If there were no points, we are drawing nothing, so return ourself.
if (-not $points) { return $this}

# Divide the width by the number of points to get a very snug bar graph
$barWidth = $width / $points.Length

# Find the maximum and minimum values in the points
$min, $max = 0, 0
foreach ($point in $points) {
    if ($point -gt $max) { $max = $point}
    if ($point -lt $min) { $min = $point}
}

# This gives us the range.
$range = $max - $min

# If the range is zero, we're drawing a flatline.
if ($range -eq 0) {
    # so just draw that line and return.
    return $this.Forward($width)
}

# Now that we've normalized the range, we can draw the bars.
for ($pointIndex =0 ; $pointIndex -lt $points.Length; $pointIndex++) {
    # Each point is essentially telling us the height
    $point = $points[$pointIndex]
    # which we can turn into a relative value
    $relativeHeight = (
        # by subtracting the minimum and dividing by the range
        (($point - $min) / $range)
    ) * $height
    # If the point was negative, we need to flip the height    
    if ($point -lt 0) { $relativeHeight *= -1}
    # Now we can draw the bar
    $this = $this.
        # Turn outward and draw the side
        Rotate(-90).Forward($relativeHeight).
        # Turn and draw the top
        Rotate(90).Forward($barWidth).
        # Turn and draw the other side
        Rotate(90).Forward($relativeHeight).
        # Turn back to the original direction
        Rotate(-90)
}
return $this




                    </Script>
      </ScriptMethod>
      <ScriptMethod>
        <Name>BezierCurve</Name>
        <Script>
                        &lt;#
.SYNOPSIS
    Draws a Bezier Curve
.DESCRIPTION
    Draws a simple Bezier curve.  
.EXAMPLE
    turtle BezierCurve 0 -100 100 -100 save ./b.svg
.EXAMPLE
    turtle BezierCurve 0 -100 100 -100 BezierCurve 100 100 100 100 save ./b2.svg
.EXAMPLE
    turtle @(
        'BezierCurve', 0, -100, 100, -100
        'BezierCurve', 100, 100, 100, 100
        'BezierCurve', 0, 100, -100, 100
    ) save ./b3.svg
.EXAMPLE
    turtle @(
        'BezierCurve', 0, -100, 100, -100
        'BezierCurve', 100, 100, 100, 100
        'BezierCurve', 0, 100, -100, 100
        'BezierCurve', -100, -100, -100, -100
    ) save ./b4.svg
.LINK
    https://en.wikipedia.org/wiki/B%C3%A9zier_curve
#&gt;
param(
# The X control point
[double]
$ControlX,

# The Y control point
[double]
$ControlY,

# The delta X
[double]
$DeltaX,

# The delta Y
[double]
$DeltaY
)



if ($DeltaX -or $DeltaY) {
    $this.Position = $DeltaX, $DeltaY
    # If the pen is down
    if ($this.IsPenDown) {
        # draw the curve
        $this.Steps.Add("s $ControlX $ControlY $DeltaX $DeltaY")
    } else {        
        # otherwise, move to the deltaX/deltaY
        $this.Steps.Add("m $DeltaX $DeltaY")
    }
}

return $this


                    </Script>
      </ScriptMethod>
      <ScriptMethod>
        <Name>BinaryTree</Name>
        <Script>
                        &lt;#
.SYNOPSIS
    Draws a binary tree
.DESCRIPTION
    Draws a binary tree using an L-system.      
.LINK
    https://en.wikipedia.org/wiki/L-system#Example_2:_fractal_(binary)_tree
#&gt;
param(
# The size of each segment
[double]$Size = 42,
# The order of magnitude (the number of times the L-system is expanded)
[int]$Order = 4,
# The angle
[double]$Angle = 45
)
return $this.Rotate(-90).LSystem('0',  [Ordered]@{
    '1' = '11'
    '0' = '1[0]0'    
}, $Order, [Ordered]@{
    '[01]'    = { $this.Forward($Size) }
    '\['      = { $this.Push().Rotate($Angle * -1) }
    '\]'      = { $this.Pop().Rotate($Angle) }
})


                    </Script>
      </ScriptMethod>
      <ScriptMethod>
        <Name>BoardFractal</Name>
        <Script>
                        &lt;#
.SYNOPSIS
    Draws a Board
.DESCRIPTION
    Draws a Board, using an L-System
.LINK
    https://paulbourke.net/fractals/lsys/
.EXAMPLE
    turtle BoardFractal 42 1
.EXAMPLE
    turtle BoardFractal 42 2
.EXAMPLE
    turtle BoardFractal 42 3
.EXAMPLE
    turtle BoardFractal 42 4
#&gt;
param(
# The size of each segment
[double]$Size = 200,
# The order of magnitude (the number of expansions)
[int]$Order = 4,
# The default angle.
[double]$Angle = 90
)
return $this.LSystem('F+F+F+F',  [Ordered]@{
    F = 'FF+F+F+F+FF'
}, $Order, [Ordered]@{
    '\+'    = { $this.Rotate($Angle) }
    'F'     = { $this.Forward($Size) }
})

                    </Script>
      </ScriptMethod>
      <ScriptMethod>
        <Name>BoxFractal</Name>
        <Script>
                        &lt;#
.EXAMPLE
    $turtle.PatternAnimation = ''    
    $turtle.Clear().BoxFractal().Pattern.Save("$pwd/BoxFractal.svg")
    
.EXAMPLE
    $turtle.Clear()
    $turtle.BoxFractal(10,4)
    $turtle.PatternTransform = @{
        'scale' = 0.9        
    }
    $turtle.PatternAnimation = "
    &lt;animateTransform attributeName='patternTransform' attributeType='XML' type='scale' values='1;0.9;1' dur='19s' repeatCount='indefinite' additive='sum' /&gt;
    &lt;animateTransform attributeName='patternTransform' attributeType='XML' type='skewY' values='0;-30;30;-30;0' dur='67s' repeatCount='indefinite' additive='sum' /&gt;
    &lt;animateTransform attributeName='patternTransform' attributeType='XML' type='skewX' values='0;-30;30;-30;0' dur='83s' repeatCount='indefinite' additive='sum' /&gt;
    "
    $turtle.Pattern.Save("$pwd/BoxFractal2.svg")
#&gt;
param(
    [double]$Size = 20,
    [int]$Order = 4,
    [double]$Angle = 90
)
return $this.LSystem('F-F-F-F',  [Ordered]@{
    F = 'F-F+F+F-F'
}, $Order, [Ordered]@{
    '\+'    = { $this.Rotate($Angle) }
    '-'     = { $this.Rotate($Angle * -1) }
    'F'     = { $this.Forward($Size) }
})


                    </Script>
      </ScriptMethod>
      <ScriptMethod>
        <Name>Circle</Name>
        <Script>
                        &lt;#
.SYNOPSIS
    Draws a circle.
.DESCRIPTION
    Draws a whole or partial circle using turtle graphics.

    That is, it draws a circle by moving the turtle forward and rotating it.

    To draw a semicircle, use an extent of 0.5.

    To draw a quarter circle, use an extent of 0.25.

    To draw a half hexagon, use an extent of 0.5 and step count of 6.
.EXAMPLE
    $turtle = New-Turtle
    $turtle.Circle(10).Pattern.Save("$pwd/CirclePattern.svg")
.EXAMPLE
    Move-Turtle Circle 10 | 
        Save-Turtle "$pwd/CirclePattern.svg" -Property Pattern
.EXAMPLE
    $turtle = New-Turtle |    
        Move-Turtle Forward 10 |
        Move-Turtle Rotate -90 |
        Move-Turtle Circle 5 |        
        Move-Turtle Circle 5 .5 |
        Move-Turtle Rotate -90 | 
        Move-Turtle Forward 10 | Save-Turtle .\DashDotDash.svg
.EXAMPLE
    $turtle = New-Turtle |    
        Move-Turtle Forward 20 |
        Move-Turtle Circle 5 .75 |
        Move-Turtle Forward 20 |
        Move-Turtle Circle 5 .75 |
        Move-Turtle Forward 20 |
        Move-Turtle Circle 5 .75 |
        Move-Turtle Forward 20 |
        Move-Turtle Circle 5 .75 |
        Save-Turtle .\CommandSymbol.svg
#&gt;
param(
[double]$Radius = 10,
[double]$Extent = 1,
[int]$StepCount = 180   
)

$circumference = 2 * [math]::PI * $Radius
$circumferenceStep = $circumference / $StepCount

if ($extent -eq 0) { return $this}

$extentMultiplier = if ($extent -gt 0) { 1 } else { -1 }

$currentExtent = 0
$maxExtent = [math]::Abs($extent)

$extentStep = 1/$StepCount

$null = foreach ($n in 1..$StepCount) {

    $this.Forward($circumferenceStep)
    $currentExtent += $extentStep

    if ($n -le $StepCount -and $currentExtent -le $maxExtent) {
        $this.Rotate( (360 / $StepCount) * $extentMultiplier)
    }

    if ($currentExtent -gt $maxExtent) {
        break
    }
}
return $this
                    </Script>
      </ScriptMethod>
      <ScriptMethod>
        <Name>CircleArc</Name>
        <Script>
                        &lt;#
.SYNOPSIS
    Draws a Circle Arc
.DESCRIPTION
    Draws a Circular Arc.

    The Turtle heading will not change, and the Turtle will end up at it's original position.
.EXAMPLE
    Turtle CircleArc
.EXAMPLE
    Turtle @(
        'CircleArc',42, 90,
        'Rotate', 90 * 4
    ) save ./Quadrants.svg
.EXAMPLE
    Turtle @(
        'CircleArc',42, 60,
        'Rotate', 60 * 6
    ) save ./Sextants.svg
.EXAMPLE
    Turtle @(
        'CircleArc',42, 45,
        'Rotate', 45 * 8
    ) save ./Octants.svg
#&gt;
param(
# The radius of the circle
[double]
$Radius = 42,

# The angle of the arc 
[double]
$Angle = 30
)

# If we wanted an angle that was a multiple of 360
# we actually want to just draw a circle
if ([Math]::Round($Angle % 360, $this.Precision) -eq 0) {
    # We start at the center
    $centerX = $this.X
    $centerY = $this.Y

    # Jump to an edge
    $this = $this.Jump($Radius)
    
    # and track the delta
    $DeltaX = $this.X - $centerX
    $DeltaY = $this.Y - $centerY


    return $this.
        # Arcing to the opposite of that delta (*2) takes us to the far edge
        Arc($Radius, $Radius, 0, $false, $false, $DeltaX * -2, $DeltaY * -2).
        # And Arcing back takes us to our original position along the edge
        Arc($Radius, $Radius, 0, $false, $false, $DeltaX * 2, $DeltaY * 2).
        # Jump back and we are back in the center of the circle.
        Jump(-$radius)                
}

# For a normal circular arc, start by pushing our location onto the stack
$this = $this.Push()
# Draw a line to the edge of the circle
$null = $this.Forward($Radius)
# This will be the wedge end
$WedgeEndX = $this.Position.X
$WedgeEndY = $this.Position.Y
# Go back to the center, rotate, and move forward by the radius.
$null = $this.Forward(-$radius)
$null = $this.Rotate($Angle).Forward($radius)
# now we can compute the distance to the end of the wedge
$DeltaX = $WedgeEndX - $this.Position.X
$DeltaY = $WedgeEndY - $this.Position.Y
# and draw an arc to this location
$this = $this.Arc($Radius, $Radius, 0, ($Angle -gt 180), $false, $DeltaX, $DeltaY)
# and then pop our position back
$null = $this.Pop()
# and return this
$null = $this.ResizeViewBox($Radius)
return $this


                    </Script>
      </ScriptMethod>
      <ScriptMethod>
        <Name>Clear</Name>
        <Script>
                        &lt;#
.SYNOPSIS
    Clears a Turtle
.DESCRIPTION
    Clears the heading, steps, position, minimim, maximum, and any nested Turtles.
.EXAMPLE
    turtle square 42 clear circle 21
#&gt;
$this.Heading = 0
if ($this.Steps.Clear) {
    $this.Steps.Clear()
}
$this | Add-Member -MemberType NoteProperty -Force -Name '.Position' -Value ([pscustomobject]@{ X = 0; Y = 0 })
$this | Add-Member -MemberType NoteProperty -Force -Name '.Minimum' -Value ([pscustomobject]@{ X = 0; Y = 0 })
$this | Add-Member -MemberType NoteProperty -Force -Name '.Maximum' -Value ([pscustomobject]@{ X = 0; Y = 0 })
$this.ViewBox = 0
$this.Turtles.Clear()
return $this
                    </Script>
      </ScriptMethod>
      <ScriptMethod>
        <Name>CrystalFractal</Name>
        <Script>
                        &lt;#
.SYNOPSIS
    Draws a Crystal Fractal
.DESCRIPTION
    Draws a Crystal Fractal, using an L-System
.LINK
    https://paulbourke.net/fractals/lsys/
.EXAMPLE
    turtle CrystalFractal 42 1
.EXAMPLE
    turtle CrystalFractal 42 2
.EXAMPLE
    turtle CrystalFractal 42 3
.EXAMPLE
    turtle CrystalFractal 42 4
#&gt;
param(
# The size of each segment
[double]$Size = 200,
# The order of magnitude (the number of expansions)
[int]$Order = 4,
# The default angle.
[double]$Angle = 90
)
return $this.LSystem('F+F+F+F',  [Ordered]@{
    F = 'FF+F++F+F'
}, $Order, [Ordered]@{
    '\+'    = { $this.Rotate($Angle) }
    'F'     = { $this.Forward($Size) }
})

                    </Script>
      </ScriptMethod>
      <ScriptMethod>
        <Name>CubicBezierCurve</Name>
        <Script>
                        
&lt;#
.SYNOPSIS
    Draws a Cubic Bezier Curve
.DESCRIPTION
    Draws a Cubic Bezier curve.

    Cubic Bezier curves take three points:

    * A Start Control Point
    * An End Control Point
    * An End Point

    A line will be drawn from the current position to the end point,
    curved towards both the start and control point.
.EXAMPLE
    turtle @(
        'CubicBezierCurve',
            200,0,  # Start Control Point 
            0,200,  # End Control Point
            200,200 # End Point        
    ) save ./cubic.svg
.EXAMPLE
    turtle width 200 height 200 morph @(
        turtle 'CubicBezierCurve',
            200,0,  # Start Control Point 
            0,200,  # End Control Point
            200,200 # End Point
            
        turtle 'CubicBezierCurve',
            0,200,  # Start Control Point 
            200,0,  # End Control Point
            200,200 # End Point
        turtle 'CubicBezierCurve',
            200,0,  # Start Control Point 
            0,200,  # End Control Point
            200,200 # End Point
    ) save ./CubicMorph.svg
.EXAMPLE
    turtle width 200 height 200 morph @(
        turtle 'CubicBezierCurve',
            200,0,    # Start Control Point 
            0,200,    # End Control Point
            200,200   # End Point
            
        turtle 'CubicBezierCurve',
            0,200,    # Start Control Point 
            200,0,    # End Control Point
            200,200   # End Point

        turtle 'CubicBezierCurve',
            200,200,  # Start Control Point 
            200,0,    # End Control Point
            200,200   # End Point
        
        turtle 'CubicBezierCurve',
            0,200,    # Start Control Point 
            0,200,    # End Control Point
            200,200   # End Point

        turtle 'CubicBezierCurve',
            400,0,    # Start Control Point 
            0,200,    # End Control Point
            200,200   # End Point

        turtle 'CubicBezierCurve',
            0,200,      # Start Control Point 
            200,0,      # End Control Point
            200,200   # End Point

        turtle 'CubicBezierCurve',
            400,0,    # Start Control Point 
            0,400,    # End Control Point
            200,200   # End Point

        turtle 'CubicBezierCurve',
            0,200,      # Start Control Point 
            200,0,      # End Control Point
            200,200   # End Point        

        turtle 'CubicBezierCurve',
            200,0,   # Start Control Point 
            0,200,   # End Control Point
            200,200  # End Point
    ) save ./MoreCubicMorphs.svg
.EXAMPLE
    # Cubic Bezier Curves are Aliased to 'c'
    turtle c 0 200 200 0 200 200 
.EXAMPLE
    turtle c 0 200 200 0 200 200 morph @(
        turtle c 0   0 0   0 200 200 
        turtle c 0 200 200 0 200 200 
        turtle c 0   0 0   0 200 200
        turtle c 200 0 0 200 200 200
        turtle c 0   0 0   0 200 200 
    ) save ./cmorph.svg
.EXAMPLE    
    turtle teleport 200 0 c 0 0 0 0 -200 200 morph @(
        turtle c 0   0 0   0 -200 200 
        turtle c 0 200 -200 0 -200 200 
        turtle c 0   0 0   0 -200 200
        turtle c -200 0 0 200 -200 200
        turtle c 0   0 0   0 -200 200 
    ) save ./cmorph2.svg
.EXAMPLE
    turtle backgroundcolor '#000000' width 200 height 200 turtles @(
        turtle width 200 height 200 morph @(
            turtle c 0   0 0   0 200 200 
            turtle c 0 200 200 0 200 200 
            turtle c 0   0 0   0 200 200
            turtle c 200 0 0 200 200 200
            turtle c 0   0 0   0 200 200 
        ) fill '#4488ff' stroke '#224488'
        turtle width 200 height 200 teleport 200 morph @(
            turtle c 0    0 0    0 -200 200 
            turtle c 0  200 -200 0 -200 200 
            turtle c 0    0 0    0 -200 200
            turtle c -200 0 0  200 -200 200
            turtle c 0    0 0    0 -200 200 
        ) stroke '#4488ff' fill '#224488'
    ) save ./cmorph3.svg
.EXAMPLE
    turtle backgroundcolor '#000000' width 200 height 200 turtles @(
        turtle width 200 height 200 morph @(
            turtle teleport 100 0 c 0 0 0 0 0 200
            turtle teleport 100 0 c -100 0 100 200 0 200
            turtle teleport 100 0 c 0 0 0 0 0 200
        ) fill '#4488ff' stroke '#224488'
        turtle width 200 height 200 teleport 200 morph @(
            turtle teleport 0 100 c 0 0 0 0 200 0
            turtle teleport 0 100 c 0 -100 200 100 200 0
            turtle teleport 0 100 c 0 0 0 0 200 0
        ) stroke '#4488ff' fill '#224488'
    ) save ./cmorph4.svg
.EXAMPLE
    turtle backgroundcolor '#000000' width 200 height 200 turtles @(
    turtle width 200 height 200 morph @(
            turtle c 0   0 0   0 200 200 
            turtle c 0 200 200 0 200 200 
            turtle c 0   0 0   0 200 200
            turtle c 200 0 0 200 200 200
            turtle c 0   0 0   0 200 200 
        ) fill '#4488ff' stroke '#224488'
        turtle width 200 height 200 teleport 200 morph @(
            turtle c 0    0 0    0 -200 200 
            turtle c 0  200 -200 0 -200 200 
            turtle c 0    0 0    0 -200 200
            turtle c -200 0 0  200 -200 200
            turtle c 0    0 0    0 -200 200 
        ) stroke '#4488ff' fill '#224488'
        turtle width 200 height 200 morph @(
            turtle teleport 100 0 c 0 0 0 0 0 200
            turtle teleport 100 0 c -100 0 100 200 0 200
            turtle teleport 100 0 c 0 0 0 0 0 200
        ) fill '#4488ff' stroke '#224488'
        turtle width 200 height 200 teleport 200 morph @(
            turtle teleport 0 100 c 0 0 0 0 200 0
            turtle teleport 0 100 c 0 -100 200 100 200 0
            turtle teleport 0 100 c 0 0 0 0 200 0
        ) stroke '#4488ff' fill '#224488'
    ) save ./cmorph5.svg
.EXAMPLE
    turtle backgroundcolor '#000000' width 200 height 200 turtles @(
        $r = @(foreach ($n in 1..4) { Get-Random -Min 0 -Max 200})
        turtle width 200 height 200 morph @(
            turtle teleport 100 0 c 0 0 0 0 0 200
            turtle teleport 100 0 c $r $r $r $r 0 200
            turtle teleport 100 0 c 0 0 0 0 0 200
        ) fill '#4488ff' stroke '#224488'
        turtle width 200 height 200 teleport 200 morph @(
            turtle teleport 0 100 c 0 0 0 0 200 0
            turtle teleport 0 100 c $r $r $r $r 200 0
            turtle teleport 0 100 c 0 0 0 0 200 0
        ) stroke '#4488ff' fill '#224488'
    ) save ./cmorphrandom.svg
.NOTES
    This corresponds to the `c` element in an SVG Path
.LINK
    https://developer.mozilla.org/en-US/docs/Web/SVG/Tutorials/SVG_from_scratch/Paths#b%C3%A9zier_curves
.LINK
    https://en.wikipedia.org/wiki/B%C3%A9zier_curve
#&gt;
param(
# The X control point
[double]
$ControlStartX,

# The Y control point
[double]
$ControlStartY,

# The X control point
[double]
$ControlEndX,

# The Y control point
[double]
$ControlEndY,

# The delta X
[double]
$DeltaX,

# The delta Y
[double]
$DeltaY
)

if ($DeltaX -or $DeltaY) {
    $this.Position = $DeltaX, $DeltaY
    # If the pen is down
    if ($this.IsPenDown) {
        # draw the curve
        $this.Steps.Add("c $ControlStartX $ControlStartY $ControlEndX $ControlEndY $DeltaX $DeltaY")
    } else {        
        # otherwise, move to the deltaX/deltaY
        $this.Steps.Add("m $DeltaX $DeltaY")
    }
}

return $this


                    </Script>
      </ScriptMethod>
      <ScriptMethod>
        <Name>Distance</Name>
        <Script>
                        &lt;#
.SYNOPSIS
    Determines the distance to a point
.DESCRIPTION
    Determines the distance from the turtle's current position to a point.
#&gt;
param()

$towards = $args | . { process { $_ } }

$tx = 0.0
$ty = 0.0

$nCount = 0
foreach ($toward in $towards) {
    if ($toward -is [double] -or $toward -is [float] -or $toward -is [int]) {
        if (-not ($nCount % 2)) {
            $tx = $toward 
        } else {
            $ty = $toward
        }
        $nCount++    
    }
    elseif ($null -ne $toward.X -and $null -ne $toward.Y) {
        $tx = $toward.x
        $ty = $toward.y
        $nCount+= 2
    }
}

$tx/=($nCount/2)
$ty/=($nCount/2)

# Determine the delta from the turtle's current position to the specified point
$deltaX = $tx - $this.Position.X 
$deltaY = $ty - $this.Position.Y

# Calculate the distance using the Pythagorean theorem
return [Math]::Sqrt($deltaX*$deltaX + $deltaY*$deltaY)
                    </Script>
      </ScriptMethod>
      <ScriptMethod>
        <Name>FillColor</Name>
        <Script>
                        param($fill = 'transparent')
$this.Fill = $fill
return $this
                    </Script>
      </ScriptMethod>
      <ScriptMethod>
        <Name>Flower</Name>
        <Script>
                        &lt;#
.SYNOPSIS
    Draws a flower pattern.
.DESCRIPTION
    Draws a flower pattern in turtle graphics.

    This pattern consists of a series of polygons and rotations to create a flower-like design.
.EXAMPLE    
    turtle Flower 42
.EXAMPLE
    turtle Flower 42 20 6 18
.EXAMPLE
    turtle Flower 42 20 6 18
.EXAMPLE
    # We can make Flowers with partial polygons
    turtle Flower 42 20 6.6 18
.EXAMPLE
    # They are surprisingly beautiful     
    turtle Flower 42 30 7.7 12
#&gt;
param(
    # The size of the base shape
    [double]$Size = 100,
    # The rotation after each step
    [double]$Rotation = 10,
    # The number of sides in each shape
    [double]$SideCount = 4,
    # The number of steps in the flower.
    [int]$StepCount = 36
)

$null = foreach ($n in 1..([Math]::Abs($StepCount))) {    
    $this.Polygon($Size, $SideCount)
    $this.Rotate($Rotation)
}

return $this
                    </Script>
      </ScriptMethod>
      <ScriptMethod>
        <Name>FlowerPetal</Name>
        <Script>
                        &lt;#
.SYNOPSIS
    Draws a flower made of petals
.DESCRIPTION
    Draws a flower made of a series of petals.  
    
    Each petal is a combination of two arcs and rotations.
.EXAMPLE
    turtle FlowerPetal 60
#&gt;
param(
# The radius of the flower
[double]
$Radius = 10,

# The rotation per step 
[double]
$Rotation = 30,

# The angle of the petal.
[double]
$PetalAngle = 60,

# The number of steps.
[ValidateRange(1,1mb)]
[int]
$StepCount = 12
)

foreach ($n in 1..$stepCount) {
    $this = $this.Petal($radius, $PetalAngle).Rotate($Rotation)    
}

return $this
                    </Script>
      </ScriptMethod>
      <ScriptMethod>
        <Name>Forward</Name>
        <Script>
                        &lt;#
.SYNOPSIS
    Moves the turtle forward
.DESCRIPTION
    Moves the turtle forward along the current heading
.EXAMPLE
    turtle forward rotate 90 forward rotate 90 forward rotate 90 forward rotate 90
#&gt;
param(
# The distance to move forward
[double]
$Distance = 10
)

#$precision = if ($this.Precision -ge 0) { $this.Precision } else { 4 }

$x = $Distance * [math]::cos($this.Heading * [Math]::PI / 180)
$y = $Distance * [math]::sin($this.Heading * [Math]::PI / 180)

return $this.Step($x, $y)

                    </Script>
      </ScriptMethod>
      <ScriptMethod>
        <Name>FractalPlant</Name>
        <Script>
                        &lt;#
.SYNOPSIS
    Draws a Fractal Plant
.DESCRIPTION
    Draws a Fractal Plant as an L-System
.LINK
    https://en.wikipedia.org/wiki/L-system#Example_7:_fractal_plant
.EXAMPLE
    turtle FractalPlant save ./FractalPlant.svg
.EXAMPLE
    turtle FractalPlant morph  save ./FractalPlantMorph.svg
#&gt;  
param(
    # The size of each segment
    [double]$Size = 42,
    # The order of magnitude (the number of times the L-system is expanded)
    [int]$Order = 4,
    # The angle of each segment
    [double]$Angle = -25
)
return $this.Rotate(-90).LSystem('-X',  [Ordered]@{
    'X' = 'F+[[X]-X]-F[-FX]+X'
    'F' = 'FF'
}, $Order, [Ordered]@{
    'F'  = { $this.Forward($Size) }
    '\+' = { $this.Rotate($angle)}
    '\-' = { $this.Rotate($angle * -1)}
    '\[' = { $this.Push() }
    '\]' = { $this.Pop() }
})
                    </Script>
      </ScriptMethod>
      <ScriptMethod>
        <Name>GoldenFlower</Name>
        <Script>
                        &lt;#
.SYNOPSIS
    Draws a golden rectangle flower pattern.
.DESCRIPTION
    Draws a flower made out of golden rectangles.

    This pattern consists of a series of rectangles and rotations to create a flower-like design.
.EXAMPLE
    Turtle GoldenFlower
.EXAMPLE
    Turtle GoldenFlower 42 10 36
.EXAMPLE
    Turtle GoldenFlower 42 5 72
.EXAMPLE
    Turtle GoldenFlower 84 30 12 | Save-Turtle ./GoldenFlowerPattern.svg Pattern
#&gt;
param(
    # The width of each rectangle
    [double]$Size = 42,
    # The rotation after each rectangle
    [double]$Rotation = 20,
    # The number of steps.
    [int]$StepCount = 18
)

$null = foreach ($n in 1..([Math]::Abs($StepCount))) {    
    $this.Rectangle($Size)
    $this.Rotate($Rotation)
}

return $this
                    </Script>
      </ScriptMethod>
      <ScriptMethod>
        <Name>GosperCurve</Name>
        <Script>
                        &lt;#
.EXAMPLE
    $turtle.Clear().GosperCurve().Pattern.Save("$pwd/GosperCurve.svg")
.EXAMPLE
    $turtle.Clear()
    $turtle.GosperCurve(20,1,60)
    $turtle.PatternTransform = @{
        'scale' = 0.5
    }
    
    $turtle.PatternAnimation = "
    &lt;animateTransform attributeName='patternTransform' attributeType='XML' type='scale' values='1;0.9;1' dur='19s' repeatCount='indefinite' additive='sum' /&gt;
    &lt;animateTransform attributeName='patternTransform' attributeType='XML' type='skewY' values='30;-30;30' dur='67s' repeatCount='indefinite' additive='sum' /&gt;
    &lt;animateTransform attributeName='patternTransform' attributeType='XML' type='skewX' values='30;-30;30' dur='83s' repeatCount='indefinite' additive='sum' /&gt;
    "
    $turtle.Pattern.Save("$pwd/GosperCurve2.svg")
#&gt;
param(
    [double]$Size = 10,
    [int]$Order = 4,
    [double]$Angle = 60
)        

return $this.LSystem('A',  @{
    A = 'A-B--B+A++AA+B-'
    B = 'A-BB--B-A++A+B'
}, $Order, ([Ordered]@{
    '\+'    = { $this.Rotate($Angle) }
    '[AB]'  = { $this.Forward($Size) }    
    '-'     = { $this.Rotate($Angle * -1) }
}))

                    </Script>
      </ScriptMethod>
      <ScriptMethod>
        <Name>GoTo</Name>
        <Script>
                        &lt;#
.SYNOPSIS
    Go to a specific position.
.DESCRIPTION
    Moves the turtle to a specific position.  
    
    If the pen is down, it will draw a line to that position.
.EXAMPLE
    Move-Turtle GoTo 10 10 | Move-Turtle Square 10 10
#&gt;
param(
# The X coordinate to move to.
[double]
$X,

# The Y coordinate to move to.
[double]
$Y
)

return $this.Step(
    $x - $this.X,
    $y - $this.Y
)
                    </Script>
      </ScriptMethod>
      <ScriptMethod>
        <Name>HatMonotile</Name>
        <Script>
                        &lt;#
.SYNOPSIS
    Draws a hat aperiodic monotile.
.DESCRIPTION
    This function uses turtle graphics to draw an aperiodic monotile called a "Hat"
.EXAMPLE
    turtle rotate -90 hatMonotile 100 save ./hatMonotile.svg
.LINK
    https://github.com/christianp/aperiodic-monotile/blob/main/hat-monotile.logo
#&gt;
param(
[double]
$A = 100,

[double]
$B = 0
)

if (-not $B) {
    $B = [Math]::Tan(60 * [Math]::PI / 180) * $A
}


return $this.
    Forward($b).
    Rotate(90).
    Forward($a).
    Left(60).
    Forward($a).
    Rotate(90).
    Forward($b).
    Rotate(60).
    Forward($b).
    Left(90).
    Forward($a).
    Rotate(60).
    Forward($a).
    Rotate(90).
    Forward($b).
    Rotate(60).
    Forward($b).
    Left(90).
    Forward($a).
    Rotate(60).
    Forward($a).
    Forward($a).
    Rotate(60).
    Forward($a).
    Rotate(90).
    Forward($b).
    Left(60)

                    </Script>
      </ScriptMethod>
      <ScriptMethod>
        <Name>HilbertCurve</Name>
        <Script>
                        param(
    [double]$Size = 10,
    [int]$Order = 5,
    [double]$Angle = 90
)        

return $this.LSystem('A',  [Ordered]@{
    A = '+BF-AFA-FB+'
    B = '-AF+BFB+FA-'
}, $Order, [Ordered]@{
    'F'     = { $this.Forward($Size) }
    '\+'    = { $this.Rotate($Angle) }
    '\-'    = { $this.Rotate($Angle * -1) }
})

                    </Script>
      </ScriptMethod>
      <ScriptMethod>
        <Name>Home</Name>
        <Script>
                        param()

return $this.Teleport(0,0)

                    </Script>
      </ScriptMethod>
      <ScriptMethod>
        <Name>HorizontalLine</Name>
        <Script>
                        &lt;#
.SYNOPSIS
    Draws a horizontal line
.DESCRIPTION
    Draws a horizontal line.  
    
    The heading will not be changed.
#&gt;
param(
[double]
$Distance
)


$this.GoTo($this.Position.X + $Distance, $this.Position.Y)

                    </Script>
      </ScriptMethod>
      <ScriptMethod>
        <Name>Jump</Name>
        <Script>
                        &lt;#
.SYNOPSIS
    Jumps the turtle forward by a specified distance
.DESCRIPTION
    Moves the turtle forward by the specified distance without drawing.

    Turtles may not be known for their jumping abilities, but they may surprise you!
.EXAMPLE
    $turtle.
        Clear().
        Rotate(45).
        Forward(10).
        Jump(20).
        Forward(10).        
        Symbol.Save("$pwd/Jump.svg")
#&gt;
param(
# The distance to jump forward
[double]$Distance
)

$this.PenUp().Forward($Distance).PenDown()

                    </Script>
      </ScriptMethod>
      <ScriptMethod>
        <Name>KochCurve</Name>
        <Script>
                        &lt;#
.SYNOPSIS
    Draws a Koch Curve
.DESCRIPTION
    Draws a Koch Curve, using an L-System.
#&gt;
param(
    [double]$Size = 10,
    [double]$Rotation = 90,
    [int]$Order = 4
)    
return $this.LSystem('F',  @{
    F = 'F+F-F-F+F'
}, $Order, [Ordered]@{
    '\+' = { $this.Rotate($Rotation) }
    'F' =  { $this.Forward($Size) }    
    '\-' = { $this.Rotate($Rotation * -1) }
})
                    </Script>
      </ScriptMethod>
      <ScriptMethod>
        <Name>KochIsland</Name>
        <Script>
                        &lt;#
.SYNOPSIS
    Generates a Koch Island
.DESCRIPTION
    Generates a Koch Island using turtle graphics.   
.EXAMPLE
    $turtle.KochIsland().Pattern.Save("$pwd/KochIsland.svg")
.EXAMPLE
    $turtle.Clear()
    $turtle.KochIsland(10,4)
    $turtle.PatternTransform = @{
        'scale' = 0.9        
    }    
    $turtle.PatternAnimation = "
    &lt;animateTransform attributeName='patternTransform' attributeType='XML' type='scale' values='1;0.9;1' dur='19s' repeatCount='indefinite' additive='sum' /&gt;
    &lt;animateTransform attributeName='patternTransform' attributeType='XML' type='skewY' values='0;-30;30;-30;0' dur='67s' repeatCount='indefinite' additive='sum' /&gt;
    &lt;animateTransform attributeName='patternTransform' attributeType='XML' type='skewX' values='0;-30;30;-30;0' dur='83s' repeatCount='indefinite' additive='sum' /&gt;
    &lt;animateTransform attributeName='patternTransform' attributeType='XML' type='rotate' values='0;360' dur='163s' repeatCount='indefinite' additive='sum' /&gt;
    &lt;animateTransform attributeName='patternTransform' attributeType='XML' type='translate' values='0 0;200 200;0 0' dur='283s' repeatCount='indefinite' additive='sum' /&gt;
    "
    $turtle.Pattern.Save("$pwd/KochIsland2.svg")
#&gt;
param(
    [double]$Size = 20,
    [int]$Order = 3,
    [double]$Angle = 90
)

return $this.LSystem('W',  [Ordered]@{
    W = 'F+F+F+F'
    F = 'F+F-F-FF+F+F-F'
}, $Order, [Ordered]@{
    '\+'    = { $this.Rotate($Angle) }
    '-'     = { $this.Rotate($Angle * -1) }
    '[FG]'  = { $this.Forward($Size) }
})

                    </Script>
      </ScriptMethod>
      <ScriptMethod>
        <Name>KochSnowflake</Name>
        <Script>
                        &lt;#
.SYNOPSIS
    Generates a Koch Snowflake.
.DESCRIPTION
    Generates a Koch Snowflake using turtle graphics.
.LINK
    https://en.wikipedia.org/wiki/Koch_snowflake#Representation_as_Lindenmayer_system
.EXAMPLE
    $turtle.KochSnowflake().Pattern.Save("$pwd/KochSnowflake.svg")
.EXAMPLE
    $turtle.Clear()
    $turtle.KochSnowflake(10,4)
    $turtle.PatternTransform = @{
        'scale' = 0.9        
    }    
    $turtle.PatternAnimation = "
    &lt;animateTransform attributeName='patternTransform' attributeType='XML' type='scale' values='1;0.9;1' dur='19s' repeatCount='indefinite' additive='sum' /&gt;
    &lt;animateTransform attributeName='patternTransform' attributeType='XML' type='skewY' values='0;-30;30;-30;0' dur='67s' repeatCount='indefinite' additive='sum' /&gt;
    &lt;animateTransform attributeName='patternTransform' attributeType='XML' type='skewX' values='0;-30;30;-30;0' dur='83s' repeatCount='indefinite' additive='sum' /&gt;
    "
    $turtle.Pattern.Save("$pwd/KochSnowflake2.svg")
#&gt;
param(
    [double]$Size = 10,    
    [int]$Order = 4,
    [double]$Rotation = 60
)    
return $this.LSystem('F--F--F ',  @{
    F = 'F+F--F+F'
}, $Order, [Ordered]@{
    '\+' = { $this.Rotate($Rotation) }
    'F' =  { $this.Forward($Size) }    
    '-' = { $this.Rotate($Rotation * -1) }
})
                    </Script>
      </ScriptMethod>
      <ScriptMethod>
        <Name>Left</Name>
        <Script>
                        &lt;#
.SYNOPSIS
    Turns the turtle left
.DESCRIPTION
    Turns the turtle left (counter-clockwise) by the specified angle.
#&gt;
param(
[double]$Angle = 90
)

$this.Rotate($Angle * -1)
                    </Script>
      </ScriptMethod>
      <ScriptMethod>
        <Name>LevyCurve</Name>
        <Script>
                        &lt;#
.SYNOPSIS
    Draws a Levy Curve
.DESCRIPTION
    Draws a Levy Curve L-System
.LINK
    https://paulbourke.net/fractals/lsys/
#&gt;
param(
# The size of each segment.
[double]$Size = 10,
# The number of expansions (the order of magnitude)
[int]$Order = 4,
# The angle
[double]$Angle = 45
)

$this.LSystem('F', @{
    F='-F++F-'
}, $Order, [Ordered]@{
    '\+' = { $this.Rotate($angle)}
    '-' = { $this.Rotate($angle * -1)}
    'F' = { $this.Forward($size)}
})


                    </Script>
      </ScriptMethod>
      <ScriptMethod>
        <Name>LSystem</Name>
        <Script>
                        &lt;#
.SYNOPSIS
    Draws a L-system pattern.
.DESCRIPTION
    Generates a pattern using a L-system.

    The initial string (Axiom) is transformed according to the rules provided for a specified number of iterations.    
.LINK
    https://en.wikipedia.org/wiki/L-system
.EXAMPLE        
    # Box Fractal L-System
    $Box = 'F-F-F-F'
    $Fractal = 'F-F+F+F-F'
    
    $turtle.Clear().LSystem(
            $Box, 
            [Ordered]@{ F = $Fractal },
            3, 
            @{
                F = { $this.Forward(10) }
                J = { $this.Jump(10) }
                '\+' = { $this.Rotate(90) }            
                '-' = { $this.Rotate(-90) }
            }
    ).Pattern.Save("$pwd/BoxFractalLSystem.svg")
.EXAMPLE
    # Fractal L-System
    $Box = 'FFFF-FFFF-FFFF-FFFF' 
    $Fractal = 'F-F+F+F-F'
        
    $turtle.Clear().LSystem(
            $Box, 
            [Ordered]@{ F = $Fractal },
            4, 
            @{
                F = { $this.Forward(10) }
                J = { $this.Jump(10) }
                '\+' = { $this.Rotate(90) }            
                '-' = { $this.Rotate(-90) }
            }
    ).Symbol.Save("$pwd/FractalLSystem.svg")
.EXAMPLE
    # Arrowhead Fractal L-System
    $Box = 'FF-FF-FF' 
    $Fractal = 'F-F+F+F-F'
    
    
    $turtle.Clear().LSystem(
            $Box, 
            [Ordered]@{ F = $Fractal },
            4, 
            @{
                F = { $this.Forward(10) }
                J = { $this.Jump(10) }
                '\+' = { $this.Rotate(90) }            
                '-' = { $this.Rotate(-90) }
            }
    ).Pattern.Save("$pwd/ArrowheadFractalLSystem.svg")
.EXAMPLE
    # Tetroid LSystem
    $turtle.Clear().LSystem(
            'F', 
            [Ordered]@{ F = 'F+F+F+F' + 
                '+JJJJ+' + 
                'F+F+F+F' + 
                '++JJJJ' +
                'F+F+F+F' +
                '++JJJJ' +
                'F+F+F+F' +
                '++JJJJ' + 
                '-JJJJ'
            },                
            3, 
            @{
                F = { $this.Forward(10) }
                J = { $this.Jump(10) }
                '\+' = { $this.Rotate(90) }            
                '-' = { $this.Rotate(-90) }
            }
    ).Pattern.Save("$pwd/TetroidLSystem.svg")

.EXAMPLE
    $turtle.Clear().LSystem(
        'F', 
        [Ordered]@{ F = '
F+F+F+F +JJJJ+ F+F+F+F ++ JJJJ' },
        3, 
        @{
            F = { $this.Forward(10) }
            J = { $this.Jump(10) }
            '\+' = { $this.Rotate(90) }            
            '-' = { $this.Rotate(-90) }
        }
    ).Pattern.Save("$pwd/LSystemCool1.svg")
.EXAMPLE
    Move-Turtle LSystem F-F-F-F ([Ordered]@{F='F-F+F+F-F'}) 3 (
        [Ordered]@{
            F = { $this.Forward(10) }
            J = { $this.Jump(10) }
            '\+' = { $this.Rotate(90) }            
            '-' = { $this.Rotate(-90) }
        }
    )
    
#&gt;
param(
# The axiom, or starting string.
[Alias('Start', 'StartString', 'Initiator')]
[string]
$Axiom,

# The rules for expanding each iteration of the axiom.
[Alias('Rules', 'ProductionRules')]
[Collections.IDictionary]
$Rule = [Ordered]@{},

# The order of magnitude (or number of iterations)
[Alias('Iterations', 'IterationCount', 'N', 'Steps', 'N','StepCount')]
[int]
$Order = 2,

# The ways each variable will be expanded.
[Collections.IDictionary]
$Variable = @{}

)

# First, let us expand our axiom
$currentState = "$Axiom"
# (at least, as long as we're supposed to)
if ($Order -ge 1) {
    $combinedPattern = "(?&gt;$($Rule.Keys -join '|'))"
    foreach ($iteration in 1..$Order) {
        # To expand each iteration, we replace any matching characters
        $currentState = $currentState -replace $combinedPattern, {
            $match = $_
            $matchingRule = $rule["$match"]
            # a matching rule could be dynamically specified with a script block
            if ($matchingRule -is [ScriptBlock]) {
                return "$(. $matchingRule $match)"
            } else {
                # but is often statically expanded with a string.
                return $matchingRule
            }
        }    
    }        
}

# Now we know our final state
$finalState = $currentState

# and can add the appropriate data attributes.
$this.PathAttribute = [Ordered]@{
    "data-l-order" = $Order
    "data-l-axiom" = $Axiom
    "data-l-rules" = ConvertTo-Json $Rule 
    "data-l-expanded" = $finalState
}

# Next, prepare our replacements.
# The provided script block will almost always be scoped differently
# so we need to recreate it.
$localReplacement = [Ordered]@{}
foreach ($key in $variable.Keys) {
    $localReplacement[$key] =
        if ($variable[$key] -is [ScriptBlock]) {
            [ScriptBlock]::Create($variable[$key])
        } else {
            $variable[$key]
        }
}

# Now we need to find all potential matches
$MatchesAny = "(?&gt;$($variable.Keys -join '|'))"
$allMatches = @([Regex]::Matches($finalState, $MatchesAny, 'IgnoreCase,IgnorePatternWhitespace'))
# we want to minimize rematching, so create a temporary cache.
$matchCache = @{}
:nextMatch foreach ($match in $allMatches) {
    $m = "$match"
    # If we have not mapped the match to a script,
    if (-not $matchCache[$m]) {
        # find the matching replacement.
        foreach ($key in $Variable.Keys) {
            if (-not ($match -match $key)) { continue }     
            $matchCache[$m] = $localReplacement[$key]
            break
        }    
    }
    
    # If we have a script to run
    if ($matchCache[$m] -is [ScriptBlock]) {
        # run it
        $null =  . $matchCache[$m] $match
        # and continue to the next match.
        continue nextMatch
    }
}

# return this so we can pipe and chain this method.
return $this

                    </Script>
      </ScriptMethod>
      <ScriptMethod>
        <Name>MooreCurve</Name>
        <Script>
                        &lt;#
.SYNOPSIS
    Generates a Moore curve.
.DESCRIPTION
    Generates a Moore curve using turtle graphics.
.LINK
    https://en.wikipedia.org/wiki/Moore_curve
.EXAMPLE
    $turtle = New-Turtle
    $turtle.MooreCurve().Pattern.Save("$pwd/MooreCurvePattern.svg")
.EXAMPLE
    Move-Turtle MooreCurve 15 5 |
        Set-Turtle Stroke '#4488ff' |
        Save-Turtle "./MooreCurve.svg"
#&gt;
param(
    [double]$Size = 10,
    [int]$Order = 4,
    [double]$Angle = 90
)        


return $this.LSystem(
    'LFL+F+LFL', 
    [Ordered]@{ 
        L = '-RF+LFL+FR-'
        R = '+LF-RFR-FL+'
    },
    4, 
    @{
        F = { $this.Forward(10) }            
        '\+' = { $this.Rotate(90) }            
        '-' = { $this.Rotate(-90) }
    }
)

                    </Script>
      </ScriptMethod>
      <ScriptMethod>
        <Name>Morph</Name>
        <Script>
                        &lt;#
.SYNOPSIS
    Morphs a Turtle
.DESCRIPTION
    Morphs a Turtle by animating its path.

    Any two paths with the same number of points can be morphed into each other smoothly.

    Any two paths with a different number of points will become a step-by-step animation.

    Since animations can include multiple complex paths, they can get quite large, and be quite beautiful.
.EXAMPLE
    $sierpinskiTriangle = turtle SierpinskiTriangle 42 4
    $SierpinskiTriangleFlipped = turtle rotate 180 SierpinskiTriangle 42 4
    turtle SierpinskiTriangle 42 4 morph (
        $SierpinskiTriangle, 
        $SierpinskiTriangleFlipped, 
        $sierpinskiTriangle
    ) save ./SierpinskiTriangleFlip.svg
.EXAMPLE
    $sideCount = (3..24 | Get-Random )
    $stepCount = 36
    
    $flower = turtle rotate ((Get-Random -Max 180) * -1) flower 42 10 $sideCount $stepCount
    $flower2 = turtle rotate ((Get-Random -Max 180)) flower 42 50 $sideCount $stepCount
    $flower3 = turtle rotate ((Get-Random -Max 90)) flower 42 20 $sideCount $stepCount
    turtle flower 42 10 $sideCount $stepCount duration ($sideCount * 3) morph ($flower, $flower2,$flower) |
        save-turtle ./flowerMorph.svg Pattern
.EXAMPLE
    $flowerAngle = (40..60 | Get-Random )
    $stepCount = 36
    $radius = 23..42 | Get-Random
    
    $flowerPetals = turtle rotate ((Get-Random -Max 180) * -1) flowerPetal $radius 10 $flowerAngle $stepCount    
    $flowerPetals3 = turtle rotate ((Get-Random -Max 180)) flowerPetal $radius 40 $flowerAngle $stepCount
    turtle flowerPetal $radius 10 $flowerAngle $stepCount duration $radius morph (
        $flowerPetals, 
        $flowerPetals3,
        $flowerPetals
    ) | Save-Turtle ./flowerPetalMorph.svg Pattern
.EXAMPLE
    turtle SierpinskiTriangle 42 4 morph |
        Save-Turtle ./SierpinskiTriangleConstruction.svg
.EXAMPLE
    turtle stroke '#224488' fill '#4488ff' backgroundColor '#112244' rotate 60 SierpinskiTriangle 42 4 SierpinskiTriangle -42 4 morph |
        Save-Turtle ./SierpinskiTriangleReflectionConstructionAndFill.svg
#&gt;
param(
[Parameter(ValueFromRemainingArguments)]
$Arguments
)

$durationArgument = $null
$hasPoints = $false
$segmentCount = 0 
$newPaths = @(foreach ($arg in $Arguments) {
    if ($arg -is [string]) {
        if ($arg -match '^\s{0,}m') {
            $arg
            $hasPoints = $true
        }
    } elseif ($arg.PathData) {
        $arg.PathData
        $hasPoints = $true
    } elseif ($arg.D) {
        $arg.D
        $hasPoints = $true
    } elseif ($arg -is [TimeSpan]) {
        $durationArgument = $arg
    }
    elseif ($arg -is [double] -or $arg -is [int]) {
        if (-not $hasPoints -and $arg -is [int]) {
            $segmentCount = [Math]::Abs($arg)
        } else {
            $durationArgument = [TimeSpan]::FromSeconds($arg)
        }        
    }
})

if (-not $newPaths) {
    if ($this.Steps.Count) {        
        $stepList = @($this.PathData -join ' ' -split '(?=\p{L})' -ne '')
        if ($segmentCount) {
            $newPaths = @(
                for ($n = 1; $n -lt $stepList.Length; $n += ($stepList.Length/$segmentCount)) {
                    $stepList[0..$n] -join ' '
                }
            )            
        } else {
            $newPaths = @(foreach ($n in 1..($stepList.Length)) {
                $stepList[0..$n] -join ' '
            })
        }
        
    } else {
        return $this
    }        
}

if ($this.PathAnimation) {
    $updatedAnimations = 
        @(foreach ($animationXML in $this.PathAnimation -split '(?&lt;=/&gt;)') {
            $animationXML = $animationXML -as [xml]
            if (-not $animationXML) { continue }
            if ($animationXML.animate.attributeName -eq 'd') {
                $animationXML.animate.values = "$($newPaths -join ';')"
            }
            $animationXML.OuterXml
        })
    $this.PathAnimation = $updatedAnimations
} else {
    $this.PathAnimation += [Ordered]@{
        attributeName = 'd'   ; values = "$($newPaths -join ';')" ; repeatCount = 'indefinite'; dur = $(
            if ($durationArgument) {
                "$($durationArgument.TotalSeconds)s"
            } elseif ($this.Duration) {
                "$($this.Duration.TotalSeconds)s"
            } else {
                "4.2s"
            }
            
        )
    }
}

return $this
                    </Script>
      </ScriptMethod>
      <ScriptMethod>
        <Name>PeanoCurve</Name>
        <Script>
                        &lt;#
.SYNOPSIS
    Generates a Peano curve.
.DESCRIPTION
    Generates a Peano curve using turtle graphics.
.LINK
    https://en.wikipedia.org/wiki/Peano_curve
.EXAMPLE
    $turtle = New-Turtle
    $turtle.PeanoCurve().Pattern.Save("$pwd/PeanoCurve.svg")
.EXAMPLE
    Move-Turtle PeanoCurve 15 5 |
        Set-Turtle Stroke '#4488ff' |
        Save-Turtle "./PeanoCurve.svg"
#&gt;
param(
    [double]$Size = 10,
    [int]$Order = 5,
    [double]$Angle = 90
)        

return $this.LSystem('X',  @{
    X = 'XFYFX+F+YFXFY-F-XFYFX'
    Y = 'YFXFY-F-XFYFX+F+YFXFY'
}, $Order, ([Ordered]@{
    '\+'    = { $this.Rotate($Angle) }
    '[F]'   = { $this.Forward($Size) }    
    '\-'    = { $this.Rotate($Angle * -1) }
}))

                    </Script>
      </ScriptMethod>
      <ScriptMethod>
        <Name>PenColor</Name>
        <Script>
                        param($stroke = 'currentColor')
$this.Stroke = $stroke
return $this
                    </Script>
      </ScriptMethod>
      <ScriptMethod>
        <Name>PenDown</Name>
        <Script>
                        $this.IsPenDown = $true
return $this

                    </Script>
      </ScriptMethod>
      <ScriptMethod>
        <Name>Pentaplexity</Name>
        <Script>
                        &lt;#
.SYNOPSIS
    Draws a Pentaplexity
.DESCRIPTION
    Draws a Pentaplexity Fractal, using an L-System
.LINK
    https://paulbourke.net/fractals/lsys/
.EXAMPLE
    turtle Pentaplexity 42 1
.EXAMPLE
    turtle Pentaplexity 42 2
.EXAMPLE
    turtle Pentaplexity 42 3
.EXAMPLE
    turtle Pentaplexity 42 4
#&gt;
param(
# The size of each segment
[double]$Size = 200,
# The order of magnitude (the number of expansions)
[int]$Order = 4,
# The default angle.
[double]$Angle = 36
)
return $this.LSystem('F++F++F++F++F',  [Ordered]@{
    F = 'F++F++F+++++F-F++F'
}, $Order, [Ordered]@{
    '\+'    = { $this.Rotate($Angle) }
    '-'     = { $this.Rotate($Angle*-1)}
    'F'     = { $this.Forward($Size) }
})

                    </Script>
      </ScriptMethod>
      <ScriptMethod>
        <Name>PenUp</Name>
        <Script>
                        $this.IsPenDown = $false
return $this

                    </Script>
      </ScriptMethod>
      <ScriptMethod>
        <Name>Petal</Name>
        <Script>
                        &lt;#
.SYNOPSIS
    Draws a petal
.DESCRIPTION
    Draws a petal.  
    
    This is a combination of two arcs and rotations.
.EXAMPLE
    turtle @('petal',100,60, 'rotate', 60 * 6)
#&gt;
param(
[double]
$Radius = 10,

[double]
$Angle = 60
)

$OppositeAngle = 180 - $Angle


$null = @(
    $this.ArcRight($Radius, $angle)
    $this.Rotate($OppositeAngle)
    $this.ArcRight($Radius, $angle)
    $this.Rotate($OppositeAngle)
)

return $this
                    </Script>
      </ScriptMethod>
      <ScriptMethod>
        <Name>PieGraph</Name>
        <Script>
                        &lt;#
.SYNOPSIS
    Draws a pie graph using turtle graphics.
.DESCRIPTION
    This script uses turtle graphics to draw a pie graph based on the provided data.
.EXAMPLE
    turtle PieGraph 400 80 20 save ./80-20.svg
.EXAMPLE
    turtle PieGraph 400 5 10 15 20 15 10 5 | Save-Turtle ./PieGraph.svg
.EXAMPLE
    turtle PieGraph 400 @{value=20;fill='red'} @{value=40;fill='blue'} save ./PieGraphColor.svg   
.EXAMPLE
    turtle PieGraph 400 @(
        5,10,15,20,15,10,5 | Sort-Object -Descending
    ) | Save-Turtle ./PieGraphDescending.svg
.EXAMPLE
    turtle rotate (Get-Random -Max 360) PieGraph 400 @(
        5,10,15,20,15,10,5 | Sort-Object -Descending
    ) | Save-Turtle ./PieGraphDescendingRotated.svg
.EXAMPLE
    turtle PieGraph 200 (
        @(1..50) | 
            Get-Random -Count (Get-Random -Minimum 5 -Maximum 20)
    ) save ./RandomPieGraph.svg
.EXAMPLE
    turtle rotate -90 piegraph 100 @(
        $allTokens = Get-Module Turtle |
            Split-Path |
            Get-ChildItem -Filter *.ps1 | 
            Foreach-Object { 
                [Management.Automation.PSParser]::Tokenize(
                    (Get-Content -Path $_.FullName -Raw), [ref]$null
                )
            }
        $allTokens |
            Group-Object Type -NoElement | 
            Sort-Object Count -Descending |
            Add-Member ScriptProperty Fill {
                "#{0:x6}" -f (Get-Random -Maximum 0xffffff)
            } -Force -PassThru |
             Add-Member ScriptProperty Link {
                "https://learn.microsoft.com/en-us/dotnet/api/system.management.automation.pstokentype?view=powershellsdk-7.4.0#system-management-automation-pstokentype-$($this.Name.ToLower())"
            } -Force -PassThru
        
    ) save ./TurtlePSTokenCountPieGraph.svg
.EXAMPLE
    turtle rotate -90 piegraph 100 @(
        $allTokens = Get-Module Turtle |
            Split-Path |
            Get-ChildItem -Filter *.ps1 | 
            Foreach-Object { 
                [Management.Automation.PSParser]::Tokenize(
                    (Get-Content -Path $_.FullName -Raw), [ref]$null
                )
            }
        $allTokens |
            Group-Object Type |
            Select-Object Name, @{
                Name='TotalLength'
                Expression = {
                    $total = 0
                    foreach ($item in $_.Group) {
                        $total+=$item.Length
                    }
                    $total
                }
            } | 
            Sort-Object TotalLength -Descending |
            Add-Member ScriptProperty Fill {
                "#{0:x6}" -f (Get-Random -Maximum 0xffffff)
            } -Force -PassThru |
             Add-Member ScriptProperty Link {
                "https://learn.microsoft.com/en-us/dotnet/api/system.management.automation.pstokentype?view=powershellsdk-7.4.0#system-management-automation-pstokentype-$($this.Name.ToLower())"
            } -Force -PassThru
        
    ) save ./TurtlePSTokenLengthPieGraph.svg
.EXAMPLE
    turtle rotate -90 piegraph 100 @(
        $allTypes = Get-Module Turtle |
            Split-Path |
            Get-ChildItem -Filter *.ps1 | 
            Get-Command -Name { $_.FullName } |
            Foreach-Object { 
                $_.ScriptBlock.Ast.FindAll({
                    param($ast)
                    $ast -is [Management.Automation.Language.TypeExpressionAst]
                }, $true)
            } |
            Foreach-Object {
                $_.Extent -replace '^\[' -replace '\]$' -as [type]
            }
        $allTypes |
            Group-Object FullName | 
            Sort-Object Count -Descending |
            Add-Member ScriptProperty Fill {
                "#{0:x6}" -f (Get-Random -Maximum 0xffffff)
            } -Force -PassThru |
             Add-Member ScriptProperty Link {
                "https://learn.microsoft.com/en-us/dotnet/api/$($this.Name.ToLower())"
            } -Force -PassThru        
    ) save ./TurtleDotNetTypesPieGraph.svg
.EXAMPLE
    $n = Get-Random -Min 5 -Max 10
    turtle width 200 height 200 morph @(
        turtle PieGraph 200 200 @(1..50 | Get-Random -Count $n)
        turtle PieGraph 200 200 @(1..50 | Get-Random -Count $n)
        turtle PieGraph 200 200 @(1..50 | Get-Random -Count $n)
    ) save ./RandomPieGraphMorph.svg
.EXAMPLE
    turtle PieGraph 200 (
        @(1..50;-1..-50) | 
            Get-Random -Count (Get-Random -Minimum 5 -Maximum 20)
    ) save ./RandomPieGraphWithNegative.svg
.EXAMPLE
    $randomNegativePie = turtle PieGraph 200 (
            @(1..50;-1..-50) | 
                Get-Random -Count 10
        )
    turtle viewbox 200 morph @(
        $randomNegativePie
        turtle PieGraph 200 200 (
            @(1..50;-1..-50) | 
                Get-Random -Count 10
        )
        $randomNegativePie
    ) save ./RandomPieGraphWithNegativeMorph.svg
.EXAMPLE
    # Multiple pie graphs
    turtle PieGraph 400 (1,2,4,8,4,2,1) jump 800 rotate 180 PieGraph 400 (1,2,4,8,4,2,1) save ./pg.svg
#&gt;
param(
# The radius of the bar graph
[double]$Radius,

# The points in the bar graph.  
# Each point will be turned into a relative number and turned into an equal-width bar.
[Parameter(ValueFromRemainingArguments)]
[PSObject[]]
$GraphData
)


# If there were no points, we are drawing nothing, so return ourself.
if (-not $GraphData) { return $this}

filter IsPrimitive {$_.GetType -and $_.GetType().IsPrimitive}

# To make a pie graph we need to know the total, and thus we need to make a couple of passes
[double]$Total = 0.0

$sliceObjects = [Ordered]@{}
$richSlices = $false
$Slices = @(
    $dataPointIndex = 0
    foreach ($dataPoint in $GraphData)
    {        
        # If the data point is a number (or other primitive data)
        if ($dataPoint | IsPrimitive)
        {
            $Total += $dataPoint # add it to the total
            $dataPoint -as [double] # and output it
            $sliceObjects["slice$($sliceObjects.Count)"] = $dataPoint
        }
        # Otherwise, if the data point has a value that is a number
        elseif ($dataPoint.value | IsPrimitive)
        {            
            $Total += $dataPoint.value # add it to the total
            $dataPoint.value -as [double] # and output that
            $richSlices = $true
            $sliceObjects["slice$($sliceObjects.Count)"] = $dataPoint
        }
        elseif ($dataPoint -is [Collections.IDictionary]) {
            foreach ($key in $dataPoint.Keys) {
                if ($dataPoint[$key] | IsPrimitive) {
                    $Total += $dataPoint[$key] # add it to the total
                    $dataPoint[$key] -as [double] # and output that
                    $sliceObjects["slice$($sliceObjects.Count)"] = $dataPoint[$key]
                }
            }
            
            $richSlices = $true
        }
        elseif ($DataPoint -is 'Microsoft.PowerShell.Commands.GroupInfo') {
            $total += $dataPoint.Count
            $dataPoint.Count
            $sliceObjects["slice$($sliceObjects.Count)"] = $dataPoint
            $richSlices = $true
        }
        elseif ($dataPoint -isnot [string]) {
            foreach ($prop in $dataPoint.psobject.properties) {
                if ($dataPoint.($prop.Name) | IsPrimitive) {
                    $Total += $dataPoint.($prop.Name) # add it to the total
                    $dataPoint.($prop.Name) -as [double] # and output that
                    $sliceObjects["slice$($sliceObjects.Count)"] = $dataPoint
                }
            }
            $richSlices = $true
        }
    }
)

if ($Slices.Length -eq 1 -and -not $richSlices) {

    # If we provide a single number, we will auto-slice the pie
    # If the number is between 0 and 1, we want to show a fraction
    if ($slices[0] -ge 0 -and $slices[0] -le 1) {        
        # Set the total to one
        $total = 1
        # and make two pie slices.
        $slices = $slices[0], (1- $slices[0])
    } else {
        # Otherwise, we want mostly equal pie slices
        # (mostly is in case of a decimal value)
        # Get the floor of our slice,
        $floor = [Math]::Floor($slices[0])
        # and determine the remainder.
        $remainder = $slices[0] - $floor
        # Then create N equal slices.
        $Slices = @(,1 * $floor)
        # If there was a remainder
        if ($remainder) {
            # create a small slice.
            $slices += $remainder
        }
        # Retotal our pie
        $total = 0.0
        foreach ($slice in $slices) {
            $total += $slice
        }        
    }    
}

# Turn each numeric slice into a ratio
$relativeSlices =
    foreach ($slice in $Slices) { $slice/ $total }

# If we have no ratios, we have nothing to graph, and we are done here.
if (-not $relativeSlices) { return $this }

# Next let's figure out the maximum delta x and delta y
$dx = $this.X + $Radius
$dy = $this.Y + $Radius
# and resize our viewbox with respect to our radius
$null = $this.ResizeViewBox($Radius)

# If we are not rendering "rich" slices, we can draw the arcs as one path
if (-not $richSlices) {
    # and we do not need to teleport
    for ($sliceNumber =0 ; $sliceNumber -lt $Slices.Length; $sliceNumber++) {
        # Turn each ratio into an angle        
        $Angle = $relativeSlices[$sliceNumber] * 360        
        $this = $this. 
                # Draw an arc of that angle,
                CircleArc($Radius, $Angle).
                # then rotate by the angle.
                Rotate($angle)
    }
}
else {
    # Otherwise, we are making multiple turtles    
    $nestedTurtles = [Ordered]@{}
    # The idea is the same, but the implementation is more complicated
    $heading = $this.Heading
    if (-not $heading) { $heading = 0.0 }    
    # Calulate the midpoint of the circle
    $midX = $this.X + ($dx - $this.X)/2
    $midY = $this.Y + ($dy - $this.Y)/2
    for ($sliceNumber =0 ; $sliceNumber -lt $Slices.Length; $sliceNumber++) {
        $Angle = $relativeSlices[$sliceNumber] * 360
        $sliceName = "slice$sliceNumber"        
        # created a nested turtle at the midpoint
        $nestedTurtles["slice$sliceNumber"] = turtle teleport $this.X $this.Y 
        # with the current heading
        $nestedTurtles["slice$sliceNumber"].Heading = $this.Heading
        # and arc by the angle
        $null = $nestedTurtles["slice$sliceNumber"].CircleArc($Radius, $Angle)

        # If the slice was of a dictionary
        if ($sliceObjects[$sliceName] -is [Collections.IDictionary])
        {
            # set any settable properties on the turtle
            foreach ($key in $sliceObjects[$sliceName].Keys) {
                # that exist in both the turtle and the dictionary
                if ($nestedTurtles[$sliceName].psobject.properties[$key].SetterScript) {
                    $nestedTurtles[$sliceName].$key = $sliceObjects[$sliceName][$key]
                }
            }
        }
        # If the slice was not a string
        elseif ($sliceObjects[$sliceName] -isnot [string])
        {
            # Set any settable properties on the turlte
            foreach ($key in $sliceObjects[$sliceName].psobject.properties.Name) {
                # that exist in both the turtle and the slice object.
                if ($nestedTurtles[$sliceName].psobject.properties[$key].SetterScript) {
                    $nestedTurtles[$sliceName].$key = $sliceObjects[$sliceName].$key
                }
            }
        }
        
        # Now rotate our own heading, even though we are not drawing anything.
        $null = $this.Rotate($angle)
    }
    # and set our nested turtles.
    $this.Turtles = $nestedTurtles
}
 
return $this
                    </Script>
      </ScriptMethod>
      <ScriptMethod>
        <Name>Polygon</Name>
        <Script>
                        &lt;#
.SYNOPSIS
    Draws a polygon
.DESCRIPTION
    Draws a regular polygon with N sides.

    To draw a closed polygon, provide a whole number of sides.

    To draw an open polygon, provide a fractial number of sides.
.EXAMPLE
    turtle polygon 42 3
.EXAMPLE
    turtle polygon 42 4
.EXAMPLE
    turtle polygon 42 6
.EXAMPLE
    turtle polygon 42 8
.EXAMPLE
    turtle polygon 42 3.75
.EXAMPLE
    turtle polygon 42 3.001 morph @(
        turtle polygon 42 3.001
        turtle polygon 42 4
        turtle polygon 42 3.001
    ) save ./TriangleToSquare.svg 

#&gt;
param(
# The default size of each segment of the polygon
[double]$Size = 42,
# The number of sides in the polygon.  
# If this is not a whole number, the polygon will not be closed.
[double]$SideCount = 6
)

# Determine the absolute side count
$absSideCount = [Math]::Abs($SideCount)
# and, for each whole number between 1 and that side count
$null = foreach ($n in 1..([Math]::Floor($absSideCount))) {
    # Rotate and move forward
    $this.Rotate(360 / $SideCount).Forward($Size)    
}
# Determine if there was a remainder
$remainder = $SideCount - [Math]::Floor($SideCount)
# If there was not, return this polygon
if (-not $remainder) { return $this }
# Otherwise, we do one more partial rotation (multiplied by the remainder)
# and draw one more line segment (multiplied by the remainder)
# (the effect will be like watching a polygon close)
return $this.Rotate((360 / $SideCount) * $remainder).Forward($remainder * $Size)


                    </Script>
      </ScriptMethod>
      <ScriptMethod>
        <Name>Pop</Name>
        <Script>
                        &lt;#
.SYNOPSIS
    Pops the Turtle Stack
.DESCRIPTION
    Pops the Turtle back to the last location and heading in the stack.    

    By pushing and popping, we can draw multiple branches.
.EXAMPLE
    # Draws a T shape by pushing and popping
    turtle rotate -90 forward 42 push rotate 90 forward 21 pop rotate -90 forward 21 show
#&gt;
param()

# If the stack is not a stack, return ourself
if ($this.'.Stack' -isnot [Collections.Stack]) { return $this }
# If the stack is empty, return ourself
if ($this.'.Stack'.Count -eq 0) { return $this }
# Pop the stack
$popped = $this.'.Stack'.Pop()

$this. # Rotate by the differene in heading, 
    Rotate($popped.Heading - $this.Heading).
    # then teleport to the popped location
    Teleport($popped.Position.X, $popped.Position.Y)

                    </Script>
      </ScriptMethod>
      <ScriptMethod>
        <Name>Push</Name>
        <Script>
                        &lt;#
.SYNOPSIS
    Pushes the Turtle Stack
.DESCRIPTION
    Pushes the current state of this Turtle onto a stack.

    If this stack is popped, the Turtle will teleport back to the location where it was pushed.

    By pushing and popping, we can draw multiple branches.
#&gt;
if (-not $this.'.Stack') {
    $this | Add-Member NoteProperty '.Stack' ([Collections.Stack]::new()) -Force
}
$this.'.Stack'.Push(@{
    Position = [Ordered]@{X=$this.Position.X;Y=$this.Position.Y}
    Heading = $this.Heading
})
return $this
                    </Script>
      </ScriptMethod>
      <ScriptMethod>
        <Name>QuadraticBezierCurve</Name>
        <Script>
                        &lt;#
.SYNOPSIS
    Draws a quadratic Bezier Curve
.DESCRIPTION
    Draws a quadratic Bezier curve.  
.EXAMPLE
    turtle QuadraticBezierCurve 0 -100 100 -100 save ./q.svg
.EXAMPLE
    turtle QuadraticBezierCurve 0 -100 100 -100 QuadraticBezierCurve 100 100 100 100 save ./q2.svg
.EXAMPLE
    turtle @(
        'QuadraticBezierCurve', 0, -100, 100, -100
        'QuadraticBezierCurve', 100, 100, 100, 100
        'QuadraticBezierCurve', 0, 100, -100, 100
    ) save ./q3.svg
.EXAMPLE
    turtle @(
        'QuadraticBezierCurve', 0, -100, 100, -100
        'QuadraticBezierCurve', 100, 0, 100, 100
        'QuadraticBezierCurve', 0, 100, -100, 100
        'QuadraticBezierCurve', -100, 0, -100, -100
    ) save ./q4.svg
#&gt;
param(
# The X control point
[double]
$ControlX,

# The Y control point
[double]
$ControlY,

# The delta X
[double]
$DeltaX,

# The delta Y
[double]
$DeltaY
)



if ($DeltaX -or $DeltaY) {
    $this.Position = $DeltaX, $DeltaY
    # If the pen is down
    if ($this.IsPenDown) {
        # draw the curve
        $this.Steps.Add("q $ControlX $ControlY $DeltaX $DeltaY")
    } else {        
        # otherwise, move to the deltaX/deltaY
        $this.Steps.Add("m $DeltaX $DeltaY")
    }
}

return $this



                    </Script>
      </ScriptMethod>
      <ScriptMethod>
        <Name>Rectangle</Name>
        <Script>
                        &lt;#
.SYNOPSIS
    Draws a Rectangle
.DESCRIPTION
    Draws a Rectangle.  
    
    If only one dimension is specified, will draw a golden rectangle.
.EXAMPLE    
    turtle rectangle 42 save ./goldenRectangle.svg
#&gt;
param(
# The width of the rectangle
[double]
$Width = 42,

# The height of the rectangle.  If not provided, will be the width divided by the golden ratio.
[double]
$Height
)

if (-not $Height) {
    $Height = $width/((1 + [Math]::Sqrt(5))/2)
}

$this.
    Forward($width).Rotate(90).
    Forward($Height).Rotate(90).
    Forward($Width).Rotate(90).
    Forward($height).Rotate(90)
                    </Script>
      </ScriptMethod>
      <ScriptMethod>
        <Name>Repeat</Name>
        <Script>
                        &lt;#
.SYNOPSIS
    Repeats Turtle Commands
.DESCRIPTION
    Repeats Turtle Commands any number of times.

    Repeat is the original loop statement in Turtle graphics.
.NOTES
    Repetition can be performed in many ways in PowerShell.

    Any example of repeat can also be written as an array with that series of steps, multiplied by the repeat count.

    ~~~PowerShell
    turtle repeat 3 [rotate 120 forward 42]
    # Produces the same shape as...
    turtle 'rotate',120,'forward',42 * 3
    # Produces the same shape as...
    turtle @(
        foreach ($n in 1..3) {
            'rotate', 120, 'forward', 42
        }
    )
    # Produces the same shape as...
    turtle @(
        foreach ($n in 1..3) {
            'rotate'
            120
            'forward'
            42
        }
    )
    ~~~

    Because repeat parses each step each time, repeat is likely to be one of the slower ways to repeat.
.EXAMPLE
    turtle repeat 3 [rotate (360/3) forward 42] save ./tri.svg
.EXAMPLE
    turtle repeat 6 [rotate (360/6) forward 42] save ./hex.svg
.EXAMPLE
    turtle repeat 7 [rotate (360/7) star 42 7] save ./starFlower.svg
.EXAMPLE
    turtle repeat 4 [rotate (360/4) forward 42 repeat 3 [rotate 120 forward 42]] save ./r.svg
.EXAMPLE
    turtle repeat 6 [rotate (360/6) forward 42 repeat 3 [rotate 120 forward 4.2]] save ./r2.svg
.EXAMPLE        
    turtle repeat 9 [rotate (
        360/9
    ) forward 84 repeat 6 [rotate (
        360/6
    ) forward 42 repeat 3 [rotate (
        360/3 
    ) forward 4.2]]] save ./r3.svg
#&gt;
param(
# The repeat count.
# This will be rounded down to the nearest integer and converted into an absolute value.
[double]
$RepeatCount,

# The steps to repeat.
[Parameter(ValueFromRemainingArguments)]
[PSObject[]]
$Command
)

# If there was no repeat count, return this
if (-not $RepeatCount) {  return $this }
$floorCount  = [Math]::Abs([Math]::Floor($RepeatCount))

if ($floorCount -ge 1) {    
    $this = $this | turtle @($Command * $floorCount)
}
return $this
                    </Script>
      </ScriptMethod>
      <ScriptMethod>
        <Name>ResizeViewBox</Name>
        <Script>
                        &lt;#
.SYNOPSIS
    Resizes the Turtle ViewBox
.DESCRIPTION
    Resizes the Turtle Viewbox to fit the current position
    
    (plus or minus a view rectangle)

    Any arguments that are primitive types will be considered a point.
#&gt;
param()

# Any argument that is a point can influence the bounding box
# (though, for the moment, we only care about the first four)
$boundingPoints = @(foreach ($arg in $args) {
    if ($arg.GetType -and $arg.GetType().IsPrimitive) {
        $arg
    }
})

# If there were no points provided, we are resizing to fit nothing new
if (-not $boundingPoints) { $boundingPoints = @(0.0) }

# Set our mins and maxes to zero
$minX, $minY, $maxX, $maxY = @(0.0) * 4
# If there was one point provided
if ($boundingPoints.Length -eq 1) {
    # we want to make sure a square of this size would fit    
    $minX, $minY, $maxX, $maxY = $boundingPoints * 4
    $minX *= -1
    $minY *= -1
}
# If there were two points provided
elseif ($boundingPoints -eq 2)
{
    # We want to make sure a rectangle of this size would fit
    $minX, $minY, $maxX, $maxY = $boundingPoints * 2
    $minX *= -1
    $minY *= -1
}
# If there were four points
elseif ($boundingPoints -eq 4) {
    # Consider those the bounds we want.
    $minX, $minY, $maxX, $maxY = $boundingPoints
}

# Make sure we have a place to store our position
if (-not $this.'.Position') {
    $this |  Add-Member -MemberType NoteProperty -Force -Name '.Position' -Value ([pscustomobject]@{ X = 0; Y = 0 })
}

# and minimum
if (-not $this.'.Minimum') {
    $this |  Add-Member -MemberType NoteProperty -Force -Name '.Minimum' -Value ([pscustomobject]@{ X = 0; Y = 0 })
}
# and maximum
if (-not $this.'.Maximum') {
    $this |  Add-Member -MemberType NoteProperty -Force -Name '.Maximum' -Value ([pscustomobject]@{ X = 0; Y = 0 })
}

# Resize our bounds as appropriate.
if ($this.Maximum.X -lt ($this.Position.X + $maxX)) {
    $this.Maximum.X = $this.Position.X + $maxX
}

if ($this.Minimum.X -gt ($this.Position.X + $minX)) {
    $this.Minimum.X = $this.Position.X + $minX
}

if ($this.Maximum.Y -lt ($this.Position.Y + $maxY)) {
    $this.Maximum.Y = $this.Position.Y + $maxY
}

if ($this.Minimum.Y -gt ($this.Position.Y + $minY)) {
    $this.Minimum.Y = $this.Position.Y + $minY
}

return $this
                    </Script>
      </ScriptMethod>
      <ScriptMethod>
        <Name>Right</Name>
        <Script>
                        &lt;#
.SYNOPSIS
    Turns the turtle right 
.DESCRIPTION
    Turns the turtle right (clockwise) by the specified angle.
#&gt;
param(
[double]$Angle = 90
)

$this.Rotate($Angle)
                    </Script>
      </ScriptMethod>
      <ScriptMethod>
        <Name>RingFractal</Name>
        <Script>
                        &lt;#
.SYNOPSIS
    Draws a Ring Fractal
.DESCRIPTION
    Draws a Ring Fractal, using an L-System
.LINK
    https://paulbourke.net/fractals/lsys/
.EXAMPLE
    turtle RingFractal 42 1
.EXAMPLE
    turtle RingFractal 42 2
.EXAMPLE
    turtle RingFractal 42 3
.EXAMPLE
    turtle RingFractal 42 4
#&gt;
param(
# The size of each segment
[double]$Size = 200,
# The order of magnitude (the number of expansions)
[int]$Order = 4,
# The default angle.
[double]$Angle = 90
)
return $this.LSystem('F+F+F+F',  [Ordered]@{
    F = 'FF+F+F+F+F+F-F'
}, $Order, [Ordered]@{
    '\+'    = { $this.Rotate($Angle) }
    '-'     = { $this.Rotate($Angle * -1)}
    'F'     = { $this.Forward($Size) }
})

                    </Script>
      </ScriptMethod>
      <ScriptMethod>
        <Name>Rotate</Name>
        <Script>
                        &lt;#
.SYNOPSIS
    Rotates the turtle.
.DESCRIPTION
    Rotates the turtle by the specified angle.
#&gt;
param([double]$Angle = 90)
$this.Heading += $Angle
return $this
                    </Script>
      </ScriptMethod>
      <ScriptMethod>
        <Name>Save</Name>
        <Script>
                        &lt;#
.SYNOPSIS
    Saves the turtle.
.DESCRIPTION
    Saves the current turtle to a file.
.LINK
    Save-Turtle
#&gt;
param(
[Parameter(Mandatory)]
[string]
$FilePath,

[string]
$Property
)

$saveSplat = [Ordered]@{FilePath = $FilePath}
if ($Property) {
    $saveSplat.Property = $property
}

return $this | Save-Turtle @saveSplat

                    </Script>
      </ScriptMethod>
      <ScriptMethod>
        <Name>Scissor</Name>
        <Script>
                        &lt;#
.SYNOPSIS
    Draws a Scissor
.DESCRIPTION
    Draws a Scissor in turtle.

    A Scissor is a pair of intersecting lines, drawn at an angle.
.EXAMPLE
    Turtle Scissor Save ./Scissor.svg
#&gt;
param(
# The distance to travel
[double]
$Distance = 10,

# The interior angle of the scissors
[double]
$Angle = 60
)


$this.
    Rotate($angle). # Rotate 
    Forward($distance). # Move Forward
    Rotate($angle * -2). # Rotate Back
    Forward($Distance). # Move Forward
    Rotate($Angle) # Rotate

                    </Script>
      </ScriptMethod>
      <ScriptMethod>
        <Name>ScissorPoly</Name>
        <Script>
                        &lt;#
.SYNOPSIS
    Draws a polygon made of Scissors    
.DESCRIPTION
    Draws a polygon made up of a series of Scissor shapes, followed by a rotation.
    
    This countiues until the total angle is approximately 360.
.EXAMPLE
    # When the angles are even divisors of 360, we get stars
    Turtle ScissorPoly 84 60 72 save ./ScissorPolyStar.svg 
.EXAMPLE    
    Turtle ScissorPoly 23 60 72 save ./ScissorPolyStar2.svg 
.EXAMPLE
    Turtle ScissorPoly 23 60 40 save ./ScissorPolyStar3.svg 
.EXAMPLE
    # When both angles exceed 180, the star starts to overlap
    Turtle ScissorPoly 23 90 120 save ./ScissorPoly.svg 
.EXAMPLE
    # When the angle is _not_ an even multiple of 360, there is much more overlap    
    Turtle ScissorPoly 16 42 42 save ./ScissorPoly.svg
.EXAMPLE
    # This can get very chaotic, if it takes a while to reach a multiple of 360
    # Build N scissor polygons
    foreach ($n in 60..72) {
        Turtle ScissorPoly 16 $n $n save ./ScissorPoly-$n.svg
    }        
.EXAMPLE
    Turtle ScissorPoly 16 69 69 save ./ScissorPoly-69.svg
.EXAMPLE
    Turtle ScissorPoly 15 72 90 save ./ScissorPoly.svg 
.EXAMPLE
    # And angle of exactly 90 will produce a series of spokes
    Turtle ScissorPoly 23 45 90 save ./Compass.svg
.EXAMPLE
    # These spokes become pointy stars as we iterate past 90
    foreach ($n in 91..99) {
        Turtle ScissorPoly 23 45 $n save "./Scissor-45-$n.svg"
    }
.EXAMPLE
    Turtle ScissorPoly 23 45 98 save ./ScissorPoly-45-98.svg
.EXAMPLE
    Turtle ScissorPoly 23 45 99 save ./ScissorPoly-45-99.svg
#&gt;
param(
# The distance of each side of the scissor
[double]
$Distance,

# The angle between each scissor
[double]
$Angle,

# The angle of each scissor, or the degree out of phase a regular N-gon would be.
[double]
$Phase
)

$totalTurn = 0

do {
    $this = $this.Scissor($Distance, $Phase).Left($angle)
    $totalTurn -= $angle
}
until (
    (-not ([Math]::Round($totalTurn, 5) % 360 ))
)

                    </Script>
      </ScriptMethod>
      <ScriptMethod>
        <Name>Show</Name>
        <Script>
                        &lt;#
.SYNOPSIS
    Shows the turtle.
.DESCRIPTION
    Shows the current turtle by opening it with the default file association
.LINK
    Save-Turtle
#&gt;
param()

return $this | Show-Turtle

                    </Script>
      </ScriptMethod>
      <ScriptMethod>
        <Name>SierpinskiArrowheadCurve</Name>
        <Script>
                        &lt;#
.SYNOPSIS
    Generates a Sierpinski Arrowhead Curve.
.DESCRIPTION
    Generates a Sierpinski Arrowhead Curve using turtle graphics.
.LINK
    https://en.wikipedia.org/wiki/Sierpi%C5%84ski_curve#Representation_as_Lindenmayer_system_2
.EXAMPLE
    $turtle.SierpinskiArrowheadCurve().Pattern.Save("$pwd/SierpinskiArrowhead.svg")
.EXAMPLE
    $turtle.Clear()
    $turtle.SierpinskiArrowheadCurve(10,4)
    $turtle.PatternTransform = @{
        'scale' = 0.9        
    }    
    $turtle.PatternAnimation = "
    &lt;animateTransform attributeName='patternTransform' attributeType='XML' type='scale' values='1;0.9;1' dur='19s' repeatCount='indefinite' additive='sum' /&gt;
    &lt;animateTransform attributeName='patternTransform' attributeType='XML' type='skewY' values='0;-30;30;-30;0' dur='67s' repeatCount='indefinite' additive='sum' /&gt;
    &lt;animateTransform attributeName='patternTransform' attributeType='XML' type='skewX' values='0;-30;30;-30;0' dur='83s' repeatCount='indefinite' additive='sum' /&gt;
    "
    $turtle.Pattern.Save("$pwd/SierpinskiArrowhead2.svg")
#&gt;

param(
    [double]$Size = 30,
    [int]$Order = 8,
    [double]$Angle = 60
)
return $this.LSystem('XF',  [Ordered]@{
    X = 'YF + XF + Y'
    Y = 'XF - YF - X'
}, $Order, [Ordered]@{
    '\+'    = { $this.Rotate($Angle)        }
    '-'     = { $this.Rotate($Angle * -1)   }
    'F'     = { $this.Forward($Size)        }
})

                    </Script>
      </ScriptMethod>
      <ScriptMethod>
        <Name>SierpinskiCurve</Name>
        <Script>
                        &lt;#
.SYNOPSIS
    Generates a Sierpinski Curve.
.DESCRIPTION
    Generates a Sierpinski Curve using turtle graphics.
.LINK
    https://en.wikipedia.org/wiki/Sierpi%C5%84ski_curve#Representation_as_Lindenmayer_system
.EXAMPLE
    $turtle.SierpinskiCurve().Pattern.Save("$pwd/SierpinskiCurve.svg")
.EXAMPLE
    $turtle.Clear()
    $turtle.SierpinskiCurve(10,4)
    $turtle.PatternTransform = @{
        'scale' = 0.9        
    }    
    $turtle.PatternAnimation = "
    &lt;animateTransform attributeName='patternTransform' attributeType='XML' type='scale' values='1;0.9;1' dur='19s' repeatCount='indefinite' additive='sum' /&gt;
    &lt;animateTransform attributeName='patternTransform' attributeType='XML' type='skewY' values='0;-30;30;-30;0' dur='67s' repeatCount='indefinite' additive='sum' /&gt;
    &lt;animateTransform attributeName='patternTransform' attributeType='XML' type='skewX' values='0;-30;30;-30;0' dur='83s' repeatCount='indefinite' additive='sum' /&gt;
    "
    $turtle.Pattern.Save("$pwd/SierpinskiCurve2.svg")
#&gt;
param(
    [double]$Size = 20,
    [int]$Order = 4,
    [double]$Angle = 45
)
return $this.LSystem('F--XF--F--XF',  [Ordered]@{
    X ='XF+G+XF--F--XF+G+X'
}, $Order, [Ordered]@{
    '\+'    = { $this.Rotate($Angle) }
    '-'     = { $this.Rotate($Angle * -1) }
    '[FG]'  = { $this.Forward($Size) }
})

                    </Script>
      </ScriptMethod>
      <ScriptMethod>
        <Name>SierpinskiSquareCurve</Name>
        <Script>
                        &lt;#
.SYNOPSIS
    Generates a Sierpinski Square Curve.
.DESCRIPTION
    Generates a Sierpinski Square Curve using turtle graphics.
.LINK
    https://en.wikipedia.org/wiki/Sierpi%C5%84ski_curve#Representation_as_Lindenmayer_system
.EXAMPLE
    $turtle.SierpinskiSquareCurve().Pattern.Save("$pwd/SierpinskiSquareCurve.svg")
.EXAMPLE
    $turtle.Clear()
    $turtle.SierpinskiSquareCurve(10,4)
    $turtle.PatternTransform = @{
        'scale' = 0.9        
    }    
    $turtle.PatternAnimation = "
    &lt;animateTransform attributeName='patternTransform' attributeType='XML' type='scale' values='1;0.9;1' dur='19s' repeatCount='indefinite' additive='sum' /&gt;
    &lt;animateTransform attributeName='patternTransform' attributeType='XML' type='skewY' values='0;-30;30;-30;0' dur='67s' repeatCount='indefinite' additive='sum' /&gt;
    &lt;animateTransform attributeName='patternTransform' attributeType='XML' type='skewX' values='0;-30;30;-30;0' dur='83s' repeatCount='indefinite' additive='sum' /&gt;
    "
    $turtle.Pattern.Save("$pwd/SierpinskiSquareCurve2.svg")
#&gt;
param(
    [double]$Size = 20,
    [int]$Order = 5,
    [double]$Angle = 90
)
return $this.LSystem('X',  [Ordered]@{
    X = 'XF-F+F-XF+F+XF-F+F-X'
}, $Order, [Ordered]@{
    '\+'    = { $this.Rotate($Angle) }
    '-'     = { $this.Rotate($Angle * -1) }
    '[FG]'  = { $this.Forward($Size) }
})

                    </Script>
      </ScriptMethod>
      <ScriptMethod>
        <Name>SierpinskiTriangle</Name>
        <Script>
                        &lt;#
.SYNOPSIS
    Generates a Sierpinski Triangle.
.DESCRIPTION
    Generates a Sierpinski Triangle using turtle graphics.
.LINK
    https://en.wikipedia.org/wiki/Sierpi%C5%84ski_triangle
.EXAMPLE
    $turtle.SierpinskiTriangle().Pattern.Save("$pwd/SierpinskiTriangle.svg")
.EXAMPLE
    $turtle.Clear()
    $turtle.SierpinskiTriangle(10,6)
    $turtle.PatternTransform = @{
        'scale' = 0.9        
    }    
    $turtle.PatternAnimation = "
    &lt;animateTransform attributeName='patternTransform' attributeType='XML' type='scale' values='1;0.9;1' dur='19s' repeatCount='indefinite' additive='sum' /&gt;
    &lt;animateTransform attributeName='patternTransform' attributeType='XML' type='skewY' values='0;-30;30;-30;0' dur='67s' repeatCount='indefinite' additive='sum' /&gt;
    &lt;animateTransform attributeName='patternTransform' attributeType='XML' type='skewX' values='0;-30;30;-30;0' dur='83s' repeatCount='indefinite' additive='sum' /&gt;
    &lt;animateTransform attributeName='patternTransform' attributeType='XML' type='rotate' values='0;360' dur='163s' repeatCount='indefinite' additive='sum' /&gt;
    &lt;animateTransform attributeName='patternTransform' attributeType='XML' type='translate' values='0 0;200 200;0 0' dur='283s' repeatCount='indefinite' additive='sum' /&gt;
    "
    $turtle.Pattern.Save("$pwd/SierpinskiTriangle2.svg")
#&gt;
param(
    [double]$Size = 200,
    [int]$Order = 2,
    [double]$Angle = 120
)
return $this.LSystem('F-G-G',  [Ordered]@{
    F = 'F-G+F+G-F'
    G = 'GG'
}, $Order, [Ordered]@{
    '\+'    = { $this.Rotate($Angle) }
    '-'     = { $this.Rotate($Angle * -1) }
    '[FG]'  = { $this.Forward($Size) }
})

                    </Script>
      </ScriptMethod>
      <ScriptMethod>
        <Name>Spirolateral</Name>
        <Script>
                        &lt;#
.SYNOPSIS
    Draws a spirolateral
.DESCRIPTION
    Draws a spirolateral
.LINK
    https://en.wikipedia.org/wiki/Spirolateral
.EXAMPLE
    turtle spirolateral save ./Spirolateral.svg
.EXAMPLE
    turtle spirolateral 50 144 8 save ./Spirolateral-144-8.svg
.EXAMPLE
    turtle spirolateral 50 60 10 save ./Spirolateral-60-10.svg
.EXAMPLE
    turtle spirolateral 50 120 6 @(1,3) save ./Spirolateral-120-6-1_3.svg
.EXAMPLE
    turtle spirolateral 50 90 11 @(3,4,5) save ./Spirolateral-90-11-3_4_5.svg
.EXAMPLE
    turtle @('spirolateral',50,60,6,@(1,3),'rotate', 60 * 6 ) save ./Spirolateral-x6.svg
#&gt;
param(
# The base length of each side (this will be multiplied by the step number)
[double]
$Side = 10,

# The angle of the turn
[double]
$Angle = 90,

# The step count.
# This is the number of times the steps will be repeated.
# This is also the maximum number of iterations the shape will complete.
[int]
$StepCount = 10,

# The step numbers that are left turns (counter-clockwise).
# This allows the creation of general spirolaterals
[Parameter(ValueFromRemainingArguments)]
[int[]]
$LeftTurnSteps
)

$stepNumber = 1
$majorStepCount = 0
$totalTurn = 0
do {
    $null = for ($stepNumber = 1; $stepNumber -le [Math]::Abs($StepCount); $stepNumber++) {
        $null = $this.Forward($side * $stepNumber)
        if ($LeftTurnSteps) {
            if ($LeftTurnSteps -contains $stepNumber) {
                $totalTurn -= $angle
                $this.Left($angle)
            } else {
                $totalTurn += $angle
                $this.Right($angle)
            }
        } else {
            $totalTurn += $angle
            $this.Right($angle)
        }
    }
    $majorStepCount++
} until (
    (-not ([Math]::Round($totalTurn, 5) % 360 )) -and 
    $majorStepCount -le [Math]::Abs($StepCount)
)

return $this

                    </Script>
      </ScriptMethod>
      <ScriptMethod>
        <Name>Square</Name>
        <Script>
                        param([double]$Size = 50)
$null = foreach ($n in 1..4) {
    $this.Forward($Size)
    $this.Rotate(90)
}
return $this
                    </Script>
      </ScriptMethod>
      <ScriptMethod>
        <Name>Star</Name>
        <Script>
                        &lt;#
.SYNOPSIS
    Draws a star pattern
.DESCRIPTION
    Draws a star pattern with turtle graphics.
.EXAMPLE
    turtle star 42 
.EXAMPLE
    turtle star 42 20
.EXAMPLE
    turtle star 42 20 @('rotate', (360/20*2), 'star', 42, 20 * 10) save ./StarFlower20.svg
.EXAMPLE
    turtle star 42 20 @('rotate', (360/20*2), 'star', 42, 20 * 10) morph @(
        turtle star 42 20 @('rotate', (360/20*2), 'star', 42, 20 * 10)
        turtle star 42 20 @('rotate', (360/20*26), 'star', 42, 20 * 10)
        turtle star 42 20 @('rotate', (360/20*2), 'star', 42, 20 * 10)        
    ) save ./StarFlower20Morph.svg
.EXAMPLE
    turtle star 42 20 @('rotate', (360/20*18), 'star', 42, 20 * 10) save ./StarFlower-20-18.svg
#&gt;
param(
    # The approximate size of the star
    [double]$Size = 50,
    # The number of points in the star
    [int]$Points = 6
)

# To determine the angle, divide 360 by the number of points
$angle = 360 / $Points

$SegmentLength = ($Size*2)/$Points
# Each 'point' in the star actually consists of two points, an inward and outward point.
# Imagine we start an an outward point
$null = foreach ($n in 1..([Math]::Abs($Points))) {
    $this. # We rotate by the angle and move forward one segment
        Rotate($Angle).Forward($SegmentLength).
        # The rotate back and move forward another segment
        Rotate(-$angle).Forward($SegmentLength).
        # then rotate once more so we continue moving around the circle
        Rotate($angle)
} # we repeat this up to the number of points in order to draw a star with no crossings.

return $this

                    </Script>
      </ScriptMethod>
      <ScriptMethod>
        <Name>StarFlower</Name>
        <Script>
                        &lt;#
.SYNOPSIS
    Draws a star flower pattern.
.DESCRIPTION
    Draws a flower made out of stars.

    This pattern consists of a series of stars and rotations to create a flower-like design.
.EXAMPLE
    Turtle StarFlower
.EXAMPLE
    Turtle StarFlower 42 20 10
.EXAMPLE
    Turtle StarFlower 42 40 13 9
.EXAMPLE
    Turtle StarFlower 84 40 6 9 | Save-Turtle ./StarFlowerPattern.svg Pattern
#&gt;
param(
    # The size of each star
    [double]$Size = 42,
    # The rotation after each star
    [double]$Rotation = 20,
    # The number of points in the star    
    [double]$PointCount = 6,
    # The number of steps.
    [int]$StepCount = 18
)

$null = foreach ($n in 1..([Math]::Abs($StepCount))) {    
    $this.Star($Size, $PointCount)
    $this.Rotate($Rotation)
}

return $this
                    </Script>
      </ScriptMethod>
      <ScriptMethod>
        <Name>Step</Name>
        <Script>
                        &lt;#
.SYNOPSIS
    Takes a Step 
.DESCRIPTION
    Makes a relative movement.
.EXAMPLE
    turtle step 5 5 step 0 -5 step -5 0 save ./stepTriangle.svg
#&gt;
param(
# The DeltaX
[double]$DeltaX = 0, 
# The DeltaY
[double]$DeltaY = 0
)

# If both coordinates are empty, there is no step
if ($DeltaX -or $DeltaY) {
    $this.Position = $DeltaX, $DeltaY
    if ($This.IsPenDown) {
        $this.Steps.Add(" l $DeltaX $DeltaY")
    } else {
        $this.Steps.Add(" m $DeltaX $DeltaY")
    }
}

return $this

                    </Script>
      </ScriptMethod>
      <ScriptMethod>
        <Name>StepSpiral</Name>
        <Script>
                        &lt;#
.SYNOPSIS
    Draws a step spiral
.DESCRIPTION
    Draws a spiral as a series of steps.

    Each step will draw a line, rotate, and increment the length of the next step.

    By default, this creates an outward spiral.

    To create an inward spiral, use a negative StepSize or StepCount.
.EXAMPLE
    turtle StepSpiral save ./StepSpiral.svg
.EXAMPLE
    turtle @('StepSpiral',3, 120, 'rotate',120 * 3) save ./StepSpiralx3.svg
.EXAMPLE
    turtle @('StepSpiral',3, 90, 'rotate',90 * 3) save ./StepSpiralx4.svg
#&gt;
param(
# The length of the first step
[double]$Length = 1,
# The angle to rotate after each step
[double]$Angle = 90,
# The amount of change per step
[double]$StepSize = 1,
# The number of steps.
[int]$StepCount = 20
)

# If the step size or count is negative
if (
    ($stepSize -lt 0 -or $stepCount -lt 0) -and
    $Length -in 0,1 # and the length is either the default or zero
) {
    # set the length to the correct maximim step size, so we can make an inward spiral.
    $Length = ([Math]::Abs($stepSize) * [Math]::Abs($stepCount))
} 
elseif ($length -eq 0) {
    # If the length is empty, default it to the step size
    $Length = $StepSize
}

# Perform the appropriate steps
foreach ($n in 1..([Math]::Abs($StepCount))) {
    $this = $this.Forward($length).Rotate($angle)
    $length += $stepSize    
}
# and return ourself.
return $this


                    </Script>
      </ScriptMethod>
      <ScriptMethod>
        <Name>Teleport</Name>
        <Script>
                        &lt;#
.SYNOPSIS
    Teleports to a specific position.
.DESCRIPTION
    Teleports the turtle to a specific position.
.EXAMPLE
    Move-Turtle Teleport 5 5 | Move-Turtle Square 10
#&gt;
param(
# The X coordinate to move to.
[double]
$X,

# The Y coordinate to move to.
[double]
$Y
)

$deltaX = $x - $this.X 
$deltaY = $y - $this.Y
$penState = $this.IsPenDown
$this.IsPenDown = $false
$null = $this.Step($deltaX, $deltaY)
$this.IsPenDown = $penState
return $this
                    </Script>
      </ScriptMethod>
      <ScriptMethod>
        <Name>TerdragonCurve</Name>
        <Script>
                        
&lt;#
.SYNOPSIS
    Generates a Terdragon Curve.
.DESCRIPTION
    Generates a Terdragon curve using turtle graphics.
.LINK
    https://en.wikipedia.org/wiki/Dragon_curve#Terdragon
.EXAMPLE
    $turtle.TerdragonCurve().Pattern.Save("$pwd/TerdragonCurve.svg")
.EXAMPLE
    $turtle.Clear()
    $turtle.TerdragonCurve(20,7,90)
    $turtle.PatternTransform = @{
        'scale' = 0.9
        'rotate' = 45
    }
    
    $turtle.PatternAnimation = "
    &lt;animateTransform attributeName='patternTransform' attributeType='XML' type='scale' values='1;0.9;1' dur='19s' repeatCount='indefinite' additive='sum' /&gt;
    &lt;animateTransform attributeName='patternTransform' attributeType='XML' type='skewY' values='30;-30;30' dur='67s' repeatCount='indefinite' additive='sum' /&gt;
    &lt;animateTransform attributeName='patternTransform' attributeType='XML' type='skewX' values='30;-30;30' dur='83s' repeatCount='indefinite' additive='sum' /&gt;
    "
    $turtle.Pattern.Save("$pwd/TerdragonCurve2.svg")
#&gt;
param(
    [double]$Size = 20,
    [int]$Order = 8,
    [double]$Angle = 120
)
return $this.LSystem('F',  [Ordered]@{
    F = 'F+F-F'    
}, $Order, [Ordered]@{
    '\+'    = { $this.Rotate($Angle) }
    '-'     = { $this.Rotate($Angle * -1) }
    '[F]'  = { $this.Forward($Size) }
})

                    </Script>
      </ScriptMethod>
      <ScriptMethod>
        <Name>TileFractal</Name>
        <Script>
                        &lt;#
.SYNOPSIS
    Draws a Tile Fractal
.DESCRIPTION
    Draws a Tile Fractal, using an L-System
.LINK
    https://paulbourke.net/fractals/lsys/
.EXAMPLE
    turtle TileFractal 42 1
.EXAMPLE
    turtle TileFractal 42 2
.EXAMPLE
    turtle TileFractal 42 3
.EXAMPLE
    turtle TileFractal 42 4
#&gt;
param(
# The size of each segment
[double]$Size = 200,
# The order of magnitude (the number of expansions)
[int]$Order = 4,
# The default angle.
[double]$Angle = 90
)
return $this.LSystem('F+F+F+F',  [Ordered]@{
    F = 'FF+F-F+F+FF'
}, $Order, [Ordered]@{
    '\+'    = { $this.Rotate($Angle) }
    '-'     = { $this.Rotate($Angle * -1)}
    'F'     = { $this.Forward($Size) }
})

                    </Script>
      </ScriptMethod>
      <ScriptMethod>
        <Name>ToString</Name>
        <Script>
                        param()

return "$($this.SVG.OuterXml)"
                    </Script>
      </ScriptMethod>
      <ScriptMethod>
        <Name>Towards</Name>
        <Script>
                        &lt;#
.SYNOPSIS
    Determines the angle towards a point
.DESCRIPTION
    Determines the angle from the turtle's current heading towards a point.
#&gt;
param()

$towards = $args | . { process { $_ } }

$tx = 0.0
$ty = 0.0

$nCount = 0
foreach ($toward in $towards) {
    if ($toward -is [double] -or $toward -is [float] -or $toward -is [int]) {
        if (-not ($nCount % 2)) {
            $tx = $toward 
        } else {
            $ty = $toward
        }
        $nCount++    
    }
    elseif ($null -ne $toward.X -and $null -ne $toward.Y) {
        $tx = $toward.x
        $ty = $toward.y
        $nCount+= 2        
    }
}

$tx/=($nCount/2)
$ty/=($nCount/2)

# Determine the delta from the turtle's current position to the specified point
$deltaX = $tx - $this.Position.X 
$deltaY = $ty - $this.Position.Y
# Calculate the angle in radians and convert to degrees
$angle = [Math]::Atan2($deltaY, $deltaX) * 180 / [Math]::PI
# Return the angle minus the current heading (modulo 360)
return $angle - ($this.Heading % 360)

                    </Script>
      </ScriptMethod>
      <ScriptMethod>
        <Name>Triplexity</Name>
        <Script>
                        &lt;#
.SYNOPSIS
    Draws a Triplexity
.DESCRIPTION
    Draws a Triplexity Fractal, using an L-System.

    Each generation of the triplexity will create an equilateral triangle with a spoke and an incomplete total rotation.
    
    Multiple generations of this seem to alternate between even numbered triangle shapes and odd numbered "lines" of triangles.
.EXAMPLE
    turtle Triplexity 42 1
.EXAMPLE
    turtle Triplexity 42 2
.EXAMPLE
    turtle Triplexity 42 3
.EXAMPLE
    turtle Triplexity 42 4
#&gt;
param(
# The size of each segment
[double]$Size = 42,
# The order of magnitude (the number of expansions)
[int]$Order = 4,
# The default angle.
[double]$Angle = 60
)
return $this.LSystem('F++F++F',  [Ordered]@{
    F = 'F++F++FFF'
}, $Order, [Ordered]@{
    '\+'    = { $this.Rotate($Angle) }
    '-'     = { $this.Rotate($Angle*-1)}
    'F'     = { $this.Forward($Size) }
})

                    </Script>
      </ScriptMethod>
      <ScriptMethod>
        <Name>TurtleMonotile</Name>
        <Script>
                        &lt;#
.SYNOPSIS
    Draws a turtle aperiodic monotile.
.DESCRIPTION
    This function uses turtle graphics to draw an aperiodic monotile called a "Turtle"
.EXAMPLE
    turtle rotate -90 turtleMonotile 100 save ./turtleMonotile.svg
.LINK
    https://github.com/christianp/aperiodic-monotile/blob/main/turtle-monotile.logo
#&gt;
param(
[double]
$A = 100,

[double]
$B = 0
)

if (-not $B) {
    $B = [Math]::Tan(60 * [Math]::PI / 180) * $A
}

return $this.
    Rotate(90).
    Forward($a).
    Rotate(60).
    Forward($a).
    Rotate(-90).
    Forward($b).
    Rotate(60).
    Forward($b).
    Forward($b).
    Rotate(60).
    Forward($b).
    Rotate(90).
    Forward($a).
    Rotate(-60).
    Forward($a).
    Rotate(90).
    Forward($b).
    Rotate(-60).
    Forward($b).
    Rotate(90).
    Forward($a).
    Rotate(60).
    Forward($a).
    Rotate(-90).
    Forward($b).
    Rotate(60).
    Forward($b)

return



                    </Script>
      </ScriptMethod>
      <ScriptMethod>
        <Name>TwinDragonCurve</Name>
        <Script>
                        &lt;#
.SYNOPSIS
    Generates a Twin Dragon Curve.
.DESCRIPTION
    Generates a Twin Dragon Curve using turtle graphics.
.LINK
    https://en.wikipedia.org/wiki/Dragon_curve#Twindragon
.EXAMPLE
    $turtle.TwinDragonCurve().Pattern.Save("$pwd/TwinDragonCurve.svg")
.EXAMPLE
    $turtle.Clear()
    $turtle.TwinDragonCurve(20,7,90)
    $turtle.PatternTransform = @{
        'scale' = 0.9
        'rotate' = 45
    }
    
    $turtle.PatternAnimation = "
    &lt;animateTransform attributeName='patternTransform' attributeType='XML' type='scale' values='1;0.9;1' dur='19s' repeatCount='indefinite' additive='sum' /&gt;
    &lt;animateTransform attributeName='patternTransform' attributeType='XML' type='skewY' values='30;-30;30' dur='67s' repeatCount='indefinite' additive='sum' /&gt;
    &lt;animateTransform attributeName='patternTransform' attributeType='XML' type='skewX' values='30;-30;30' dur='83s' repeatCount='indefinite' additive='sum' /&gt;
    "
    $turtle.Pattern.Save("$pwd/TwinDragonCurve2.svg")
#&gt;

param(
    [double]$Size = 20,
    [int]$Order = 6,
    [double]$Angle = 90
)
return $this.LSystem('FX+FX+',  [Ordered]@{
    X = 'X+YF'
    Y = 'FX-Y'
}, $Order, [Ordered]@{
    '\+'    = { $this.Rotate($Angle) }
    '-'     = { $this.Rotate($Angle * -1) }
    '[F]'  = { $this.Forward($Size) }
})

                    </Script>
      </ScriptMethod>
      <ScriptMethod>
        <Name>VerticalLine</Name>
        <Script>
                        &lt;#
.SYNOPSIS
    Draws a vertical line
.DESCRIPTION
    Draws a vertical line.  
    
    The heading will not be changed.
#&gt;
param(
[double]
$Distance
)

$this.GoTo($this.Position.X, $this.Position.Y + $Distance)

                    </Script>
      </ScriptMethod>
      <ScriptMethod>
        <Name>xcor</Name>
        <Script>
                        return $this.Position.X
                    </Script>
      </ScriptMethod>
      <ScriptMethod>
        <Name>ycor</Name>
        <Script>
                        return $this.Position.Y
                    </Script>
      </ScriptMethod>
      <ScriptProperty>
        <Name>AnimateMotion</Name>
        <GetScriptBlock>
                        &lt;#
.SYNOPSIS
    Gets a Turtle's animation motion
.DESCRIPTION
    Gets a Turtle's path as an animation motion.

    This only provides the animation path of this turtle, not any turtles contained within this turtle.
#&gt;
[OutputType([xml])]
param()

[xml]@(
"&lt;animateMotion dur='$(
    if ($this.Duration -is [TimeSpan]) {
        "$($this.Duration.TotalSeconds)s"
    } else {
        "$(($this.Points.Length / 2 / 10))s"
    }
)' repeatCount='indefinite' path='$($this.PathData)' /&gt;
")
                    </GetScriptBlock>
      </ScriptProperty>
      <ScriptProperty>
        <Name>AnimateMotionDuration</Name>
        <GetScriptBlock>
                        if ($this.'.AnimateMotionDuration') {
    return $this.'.AnimateMotionDuration'
}
$thesePoints = $this.Points
if ($thesePoints.Length -eq 0) {
    return "$(($thesePoints.Length / 2 / 10))s"
}

                    </GetScriptBlock>
        <SetScriptBlock>
                        param(
[PSObject]
$AnimateMotionDuration
)

if ($AnimateMotionDuration -is [TimeSpan]) {
    $AnimateMotionDuration = $AnimateMotionDuration.TotalSeconds + 's'
}

if ($AnimateMotionDuration -is [int] -or $AnimateMotionDuration -is [double]) {
    $AnimateMotionDuration = "${AnimateMotionDuration}s"
}

$this | Add-Member -MemberType NoteProperty -Force -Name '.AnimateMotionDuration' -Value $AnimateMotionDuration

                    </SetScriptBlock>
      </ScriptProperty>
      <ScriptProperty>
        <Name>BackgroundColor</Name>
        <GetScriptBlock>
                        param()

if ($this.'.BackgroundColor') {
    return $this.'.BackgroundColor'
}

                    </GetScriptBlock>
        <SetScriptBlock>
                        param(
[PSObject]
$value
)

$this | Add-Member NoteProperty -Name '.BackgroundColor' -Value $value -Force

                    </SetScriptBlock>
      </ScriptProperty>
      <ScriptProperty>
        <Name>Canvas</Name>
        <GetScriptBlock>
                        &lt;#
.SYNOPSIS
    Gets a turtle canvas
.DESCRIPTION
    Gets a turtle a canvas element.
#&gt;
@(
    $viewBox = $this.ViewBox
    $null, $null, $viewX, $viewY = $viewBox    
    "&lt;canvas id='$($this.ID)-canvas'&gt;&lt;/canvas&gt;"    
    "&lt;script type='module'&gt;"    
@"
window.onload = async function() {
    const loadImage = async url =&gt; {
        const newImage = document.createElement('img')
        newImage.src = url
        return new Promise((resolve, reject) =&gt; {
            newImage.onload = () =&gt; resolve(newImage)
            newImage.onerror = reject
        })
    }
    const dataHeader = 'data:image/svg+xml;charset=utf-8'
    const serializeAsXML = e =&gt; (new XMLSerializer()).serializeToString(e)
    const encodeAsUTF8 = s =&gt; ```${dataHeader},`${encodeURIComponent(s)}``

    const img = await loadImage('$($this.DataUrl)')  
    
    var canvas = document.getElementById('$($this.ID)-canvas');
    canvas.width = $viewX
    canvas.height = $viewY
    var ctx = canvas.getContext('2d')
    ctx.drawImage(img, 0, 0, $viewX, $viewY)
    /*Insert-Post-Processing-Here*/
}
"@
    "&lt;/script&gt;"
)


                    </GetScriptBlock>
      </ScriptProperty>
      <ScriptProperty>
        <Name>Class</Name>
        <GetScriptBlock>
                        &lt;#
.SYNOPSIS
    Gets a Turtle's class
.DESCRIPTION
    Gets any CSS classes associated with the turtle
.EXAMPLE
    turtle class foo bar baz bing class
#&gt;
return $this.SVGAttribute["class"] -split '\s+'

                    </GetScriptBlock>
        <SetScriptBlock>
                        &lt;#
.SYNOPSIS
    Sets a Turtle's class
.DESCRIPTION
    Sets any CSS classes associated with the turtle
.EXAMPLE
    turtle class foo bar baz bing class
#&gt;
param(
$Class
)

$this.SVGAttribute['class'] = $Class -join ' '

                    </SetScriptBlock>
      </ScriptProperty>
      <ScriptProperty>
        <Name>ClipPath</Name>
        <GetScriptBlock>
                        "clip-path: path(`"$($this.PathData)`");"
                    </GetScriptBlock>
      </ScriptProperty>
      <ScriptProperty>
        <Name>DataBlock</Name>
        <GetScriptBlock>
                        &lt;#
.SYNOPSIS
    Gets a Turtle as data block
.DESCRIPTION
    Gets our Turtle as a data block that will recreate our Turtle.

    The only commands that can be used in the data block are: `Turtle`, `Get-Turtle`, and `Get-Random`
.NOTES
    PowerShell data blocks provide a much more limited syntax.  
    
    They can only use simple expressions, cannot declare variables, use loops, declare script blocks, or use most types.

    They can also be declared with whitelist of Supported Commands.

    This property will return the current turtle inside of a data block, if possible.
    
    If any errors occur during conversion, they will be present in `$error`.
.LINK
    https://learn.microsoft.com/en-us/powershell/module/microsoft.powershell.core/about/about_data_sections?wt.mc_id=MVP_321542
#&gt;
[OutputType([ScriptBlock])]
param()
[ScriptBlock]::Create("data -supportedCommand turtle, Get-Turtle, Get-Random {
    $($this.ScriptBlock)
}")


                    </GetScriptBlock>
      </ScriptProperty>
      <ScriptProperty>
        <Name>DataURL</Name>
        <GetScriptBlock>
                        &lt;#
.SYNOPSIS
    Gets the turtle data URL.
.DESCRIPTION
    Gets the turtle symbol as a data URL.
    
    This can be used as an inline image in HTML, CSS, or Markdown.
#&gt;
$thisSVG = $this.SVG
"data:image/svg+xml;base64,$(
    [Convert]::ToBase64String($OutputEncoding.GetBytes($this.SVG.outerXml))
)"
                    </GetScriptBlock>
      </ScriptProperty>
      <ScriptProperty>
        <Name>Defines</Name>
        <GetScriptBlock>
                        if ($this.'.Defines') {
    return $this.'.Defines'
}

                    </GetScriptBlock>
        <SetScriptBlock>
                        &lt;#
.SYNOPSIS
    Sets the Turtle Path Animation
.DESCRIPTION
    Sets an animation for the Turtle path.
.EXAMPLE
    $t = turtle defines @(
        "&lt;radialGradient id='gradient'&gt;
            &lt;stop offset='33%' stop-color='red' /&gt;
            &lt;stop offset='66%' stop-color='green' /&gt;
            &lt;stop offset='100%' stop-color='blue' /&gt;
        &lt;/radialGradient&gt;"
        "&lt;radialGradient id='gradient2'&gt;
            &lt;stop offset='33%' stop-color='blue' /&gt;
            &lt;stop offset='66%' stop-color='green' /&gt;
            &lt;stop offset='100%' stop-color='red' /&gt;
        &lt;/radialGradient&gt;"

    ) flower 42 fill 'url("#gradient")' stroke 'url("#gradient2")'     
    $t | turtle save ./gradient.svg
.EXAMPLE
    $t = turtle defines @(
        "&lt;radialGradient id='gradient'&gt;
            &lt;stop offset='33%' stop-color='red' /&gt;
            &lt;stop offset='66%' stop-color='green' /&gt;
            &lt;stop offset='100%' stop-color='blue' /&gt;
        &lt;/radialGradient&gt;"
        "&lt;radialGradient id='gradient2'&gt;
            &lt;stop offset='33%' stop-color='blue' /&gt;
            &lt;stop offset='66%' stop-color='green' /&gt;
            &lt;stop offset='100%' stop-color='red' /&gt;
        &lt;/radialGradient&gt;"        
    ) width 100 height 100 teleport 50 50 StarFlower 42 14.4 6 25 fill 'url("#gradient")' stroke 'url("#gradient2")' fillrule evenodd morph @(
        turtle teleport 50 50 StarFlower 42 12 5 30
        turtle teleport 50 50 StarFlower 42 14.4 6 25
        turtle teleport 50 50 StarFlower 42 12 5 30
    ) PathAnimation ( [Ordered]@{
        type = 'rotate'   ; values = 0, 360 ;repeatCount = 'indefinite'; dur = "4.2s"
    }) 
    $t | turtle save ./gradientrotate.svg
#&gt;
param(
# The definition object.
# This may be a string, XML, a dictionary containing defines, or an element
[PSObject]
$Defines
)

$newDefinition = @(foreach ($definition in $Defines) {
    if ($definition -is [Collections.IDictionary]) {
        $definitionCopy = [Ordered]@{} + $definition                
        "&lt;$elementName $(
            @(foreach ($key in $definitionCopy.Keys) {
                if ($key -eq 'Children') { continue }
                " $key='$([Web.HttpUtility]::HtmlAttributeEncode($definitionCopy[$key]))'"
            }) -join ''
        )$()&gt;"
    }
    elseif ($definition -is [string]) {
        $definition
    }    
    elseif ($definition.OuterXml) {
        $definition.OuterXml
    }
    else {
        "$definition"
    }
})

$this | Add-Member -MemberType NoteProperty -Force -Name '.Defines' -Value $newDefinition

                    </SetScriptBlock>
      </ScriptProperty>
      <ScriptProperty>
        <Name>Duration</Name>
        <GetScriptBlock>
                        &lt;#
.SYNOPSIS
    Gets the duration
.DESCRIPTION
    Gets the default duration of animations and morphs.

    By default, 4.2 seconds.
#&gt;
if ($null -eq $this.'.Duration') { 
    $this | Add-Member NoteProperty '.Duration' ([timespan]::FromSeconds(4.2)) -Force
}
return $this.'.Duration'

                    </GetScriptBlock>
        <SetScriptBlock>
                        &lt;#
.SYNOPSIS
    Sets the duration
.DESCRIPTION
    Sets the default duration used for morphs and other animations.
#&gt;
param(
# The value to set
$value
)

foreach ($v in $value) {
    if ($v -is [double] -or $v -is [int]) {
        $this | Add-Member NoteProperty '.Duration' ([TimeSpan]::FromSeconds($v)) -Force
    } elseif ($v -as [TimeSpan]) {
        $this | Add-Member NoteProperty '.Duration' ($v -as [Timespan]) -Force
    } else {
        Write-Warning "'$Value' is not a number or timespan"
    }
}

if (($this.'.Duration' -is [TimeSpan]) -and $this.PathAnimation) {
    $updatedAnimations =
        @(foreach ($animationXML in $this.PathAnimation -split '(?&lt;=/&gt;)') {
            $animationXML = $animationXML -as [xml]
            if (-not $animationXML) { continue }
            if ($animationXML.animate.attributeName -eq 'd') {
                $animationXML.animate.dur = "$(($this.'.Duration').TotalSeconds)s"
            }
            $animationXML.OuterXml
        })
    $this.PathAnimation = $updatedAnimations
}
                    </SetScriptBlock>
      </ScriptProperty>
      <ScriptProperty>
        <Name>Fill</Name>
        <GetScriptBlock>
                        if ($this.'.Fill') { 
    return $this.'.Fill'
}
return 'transparent'
                    </GetScriptBlock>
        <SetScriptBlock>
                        param(
    [string]$Fill = 'transparent'
)

if (-not $this.'.Fill') {
    $this | Add-Member -MemberType NoteProperty -Name '.Fill' -Value $Fill -Force
} else {
    $this.'.Fill' = $Fill
}
                    </SetScriptBlock>
      </ScriptProperty>
      <ScriptProperty>
        <Name>FillRule</Name>
        <GetScriptBlock>
                        if (-not $this.'.PathAttribute') {
    $this | Add-Member -MemberType NoteProperty -Name '.PathAttribute' -Value ([Ordered]@{}) -Force
}
if ($this.'.PathAttribute'.'fill-rule') {
    return $this.'.PathAttribute'.'fill-rule'
} else {
    'nonzero'
}
                    </GetScriptBlock>
        <SetScriptBlock>
                        param(
[ValidateSet('nonzero', 'evenodd')]
[string]
$fillRule = 'nonzero'
)
$this.PathAttribute = [Ordered]@{'fill-rule' = $fillRule.ToLower()}

                    </SetScriptBlock>
      </ScriptProperty>
      <ScriptProperty>
        <Name>Heading</Name>
        <GetScriptBlock>
                        &lt;#
.SYNOPSIS
    Gets the turtle's heading.
.DESCRIPTION
    Gets the current heading of the turtle.
#&gt;
param()
if ($this -and -not $this.psobject.properties['.TurtleHeading']) {
    $this.psobject.properties.add([PSNoteProperty]::new('.TurtleHeading', 0.0), $false)
}
return $this.'.TurtleHeading'


                    </GetScriptBlock>
        <SetScriptBlock>
                        &lt;#
.SYNOPSIS
    Sets the turtle's heading.
.DESCRIPTION
    Sets the turtle's heading.  
    
    This is one of two key properties of the turtle, the other being its position.
#&gt;
param(
# The new turtle heading.  
[double]
$Heading
)

if ($this -and -not $this.psobject.properties['.TurtleHeading']) {
    $this.psobject.properties.add([PSNoteProperty]::new('.TurtleHeading', 0), $false)
}
$this.'.TurtleHeading' = $Heading
                    </SetScriptBlock>
      </ScriptProperty>
      <ScriptProperty>
        <Name>Height</Name>
        <GetScriptBlock>
                        &lt;#
.SYNOPSIS
    Gets the Turtle height
.DESCRIPTION
    Gets the Turtle's ViewBox height.
.NOTES
    If this has not been set, it will be automatically computed from the distance between the minimum and maximum.
.EXAMPLE
    turtle rotate 90 forward 100 width
#&gt;
param()
if ($this.'.ViewBox') { 
    return @($this.'.ViewBox')[-1]
}

$viewY = $this.Maximum.Y + ($this.Minimum.Y * -1)
return $viewY




                    </GetScriptBlock>
        <SetScriptBlock>
                        &lt;#
.SYNOPSIS
    Sets the turtle height
.DESCRIPTION
    Sets the Turtle viewbox height.
.NOTES
    Once set, it will no longer be automatically computed.
#&gt;
param(
[double]
$height
)

$viewBox = $this.ViewBox
$this.ViewBox = $viewBox[0],$viewBox[1],$viewbox[-2], $height

                    </SetScriptBlock>
      </ScriptProperty>
      <ScriptProperty>
        <Name>History</Name>
        <GetScriptBlock>
                        &lt;#
.SYNOPSIS
    Gets a Turtle's history
.DESCRIPTION
    Gets an annotated history of a turtle's movements.

    This is an SVG path translated into back into human readable text and coordinates.
#&gt;
$currentPosition = [Numerics.Vector2]::new(0,0)
$historyList = [Collections.Generic.List[PSObject]]::new()
$startStack = [Collections.Stack]::new()
foreach ($pathStep in $this.PathData -join ' ' -split '(?=[\p{L}-[E]])' -ne '') {
    $letter = $pathStep[0]
    $isUpper = "$letter".ToLower() -cne $letter
    $isLower = -not $isUpper
    $toBy = if ($isUpper) { 'to'} else { 'by'}    
    $stepPoints = $pathStep -replace $letter -replace ',', ' ' -split '\s{1,}' -ne '' -as [float[]]
    
    $historyEntry = 
    switch ($letter) {
        a {            
            for ($stepIndex = 0; $stepIndex -lt $stepPoints.Length; $stepIndex+=7) {
                $sequence = $stepPoints[$stepIndex..($stepIndex + 6)]
                $comment = "arc $toBy $sequence"
                $delta = [Numerics.Vector2]::new.Invoke($sequence[-2,-1])
                if ($isUpper) { $delta -= $currentPosition }
                [PSCustomObject]@{
                    PSTypeName='Turtle.History'
                    Letter = "$letter"
                    Start = $currentPosition
                    End = $currentPosition + $delta
                    Delta = $delta
                    Instruction = "$Letter $sequence"                    
                    Comment = $comment
                }
                $currentPosition += $delta
            }
        }
        c {
            
            for ($stepIndex = 0; $stepIndex -lt $stepPoints.Length; $stepIndex+=6) {
                $sequence = $stepPoints[$stepIndex..($stepIndex + 5)]
                $comment = "cubic curve $toBy $sequence"
                $delta = [Numerics.Vector2]::new.Invoke($sequence[-2,-1])
                if ($isUpper) { $delta -= $currentPosition }
                [PSCustomObject]@{
                    PSTypeName='Turtle.History'
                    Letter = "$letter"
                    Start = $currentPosition
                    End = $currentPosition + $delta
                    Delta = $delta
                    Instruction = "$Letter $sequence"                    
                    Comment = $comment
                }
                $currentPosition += $delta
            }
        }
        l {
            # line segment
            for ($stepIndex = 0; $stepIndex -lt $stepPoints.Length; $stepIndex+=2) {
                $sequence = $stepPoints[$stepIndex..($stepIndex + 1)]
                $comment = "line $toBy $sequence"
                $delta = [Numerics.Vector2]::new.Invoke($sequence[-2,-1])
                if ($isUpper) { $delta -= $currentPosition }
                [PSCustomObject]@{
                    PSTypeName='Turtle.History'
                    Letter = "$letter"
                    Start = $currentPosition
                    End = $currentPosition + $delta
                    Delta = $delta
                    Instruction = "$Letter $sequence"
                    Comment = $comment
                }
                $currentPosition += $delta
            }
        }
        m { 
            # movement
            for ($stepIndex = 0; $stepIndex -lt $stepPoints.Length; $stepIndex+=2) {
                $sequence = $stepPoints[$stepIndex..($stepIndex + 1)]

                $comment = "line $toBy $sequence"

                $delta = [Numerics.Vector2]::new.Invoke($sequence[-2,-1])
                
                if ($isUpper) { $delta -= $currentPosition }

                if ($stepIndex -gt 0) {                    
                    if ($letter -eq 'm') {
                        if ($isUpper) { $letter = 'L' }
                        else { $letter = 'l'}
                    }
                    $comment = "line $toBy $sequence"                    
                } else {
                    $comment = "move $toBy $sequence"
                    $startStack.Push($currentPosition + $delta)
                }
                
                [PSCustomObject]@{
                    PSTypeName='Turtle.History'
                    Letter = "$letter"
                    Start = $currentPosition
                    End = $currentPosition + $delta
                    Delta = $delta
                    Instruction = "$Letter $sequence"
                    Comment = $comment
                }
                $currentPosition += $delta
            }
        }
        s {
            # simple bezier curve
            for ($stepIndex = 0; $stepIndex -lt $stepPoints.Length; $stepIndex+=4) {
                $sequence = $stepPoints[$stepIndex..($stepIndex + 3)]
                $comment = "simple bezier curve $toBy $sequence"
                $delta = [Numerics.Vector2]::new.Invoke($sequence[-2,-1])
                if ($isUpper) { $delta -= $currentPosition }
                [PSCustomObject]@{
                    PSTypeName='Turtle.History'
                    Letter = "$letter"
                    Start = $currentPosition
                    End = $currentPosition + $delta
                    Delta = $delta
                    Instruction = "$Letter $sequence"
                    Comment = $comment
                }                
                $currentPosition += $delta
            }
        }
        t {
            # continue simple bezier curve            
            for ($stepIndex = 0; $stepIndex -lt $stepPoints.Length; $stepIndex+=2) {
                $sequence = $stepPoints[$stepIndex..($stepIndex + 1)]
                $comment = "continue bezier curve $toBy $sequence"
                $delta = [Numerics.Vector2]::new.Invoke($sequence[-2,-1])
                if ($isUpper) { $delta -= $currentPosition }
                [PSCustomObject]@{
                    PSTypeName='Turtle.History'
                    Letter = "$letter"
                    Start = $currentPosition
                    End = $currentPosition + $delta
                    Delta = $delta
                    Instruction = "$Letter $sequence"
                    Comment = $comment
                }                
                $currentPosition += $delta
            } 
        }
        q {            
            for ($stepIndex = 0; $stepIndex -lt $stepPoints.Length; $stepIndex+=4) {
                
                $sequence = $stepPoints[$stepIndex..($stepIndex + 3)]
                $comment = "quadratic bezier curve $toBy $sequence"
                $delta = [Numerics.Vector2]::new.Invoke($sequence[-2,-1])
                if ($isUpper) { $delta -= $currentPosition }
                [PSCustomObject]@{
                    PSTypeName='Turtle.History'
                    Letter = "$letter"
                    Start = $currentPosition
                    End = $currentPosition + $delta
                    Delta = $delta
                    Instruction = "$Letter $sequence"
                    Comment = $comment
                }                
                $currentPosition += $delta
            }
        }
        { $_ -in 'h', 'v' } {
            for ($stepIndex = 0; $stepIndex -lt $stepPoints.Length; $stepIndex++) {                
                $sequence = $stepPoints[$stepIndex..$stepIndex]
                $comment = "$(
                        if ($letter -eq 'v') { 'vertical' } else {'horizontal'}
                ) line $toBy $sequence"
                $delta = 
                    if ($letter -eq 'v') {
                        [Numerics.Vector2]::new(0, $sequence[0])
                    } else {
                        [Numerics.Vector2]::new($sequence[0], 0)
                    }
                if ($isUpper) { $delta -= $currentPosition }
                [PSCustomObject]@{
                    PSTypeName='Turtle.History'
                    Letter = "$letter"
                    Start = $currentPosition
                    End = $currentPosition + $delta
                    Delta = $delta
                    Instruction = "$Letter $sequence"
                    Comment = $comment
                }                
                $currentPosition += $delta
            }                        
        }        
        z {
            $closePosition = $startStack.Pop()
            $delta = $closePosition - $currentPosition
            [PSCustomObject]@{
                PSTypeName='Turtle.History'
                Letter = "$letter"
                Start = $currentPosition
                End = $currentPosition + $delta
                Delta = $delta
                Instruction = "$Letter"
                Comment = "close path"
            }
            $currentPosition += $delta
            
        }                
    }

    $historyList.Add($historyEntry)
}


return $historyList
                    </GetScriptBlock>
      </ScriptProperty>
      <ScriptProperty>
        <Name>ID</Name>
        <GetScriptBlock>
                        if ($this.'.ID') { return $this.'.ID'}
return 'turtle'

                    </GetScriptBlock>
        <SetScriptBlock>
                        param([string]$Value)

$this | Add-Member NoteProperty '.ID' $Value -Force

                    </SetScriptBlock>
      </ScriptProperty>
      <ScriptProperty>
        <Name>IsPenDown</Name>
        <GetScriptBlock>
                        if ($null -ne $this.'.IsPenDown') { return $this.'.IsPenDown' }
return $true

                    </GetScriptBlock>
        <SetScriptBlock>
                        param(
[bool]
$IsDown
)
if ($null -eq $this.'.IsPenDown') {
    $this | Add-Member -MemberType NoteProperty -Force -Name '.IsPenDown' -Value $IsDown
} else {
    $this.'.IsPenDown' = $IsDown
}

                    </SetScriptBlock>
      </ScriptProperty>
      <ScriptProperty>
        <Name>JPEG</Name>
        <GetScriptBlock>
                        $chromiumNames = 'chromium','chrome'
foreach ($browserName in $chromiumNames) {
    $chromiumCommand = 
        $ExecutionContext.SessionState.InvokeCommand.GetCommand($browserName,'Application')
    if (-not $chromiumCommand) { 
        $chromiumCommand = 
            Get-Process -Name $browserName -ErrorAction Ignore | 
            Select-Object -First 1 -ExpandProperty Path
    }
    if ($chromiumCommand) { break }
}
if (-not $chromiumCommand) {
    Write-Error "No Chromium-based browser found. Please install one of: $($chromiumNames -join ', ')"
    return
}

$pngRasterizer = $this.Canvas -replace '/\*Insert-Post-Processing-Here\*/', @'
    const dataUrl = await canvas.toDataURL('image/jpeg')
    console.log(dataUrl)
  
    const newImage = document.createElement('img')
    newImage.src = dataUrl
    document.body.appendChild(newImage)
'@


$appDataRoot = [Environment]::GetFolderPath("ApplicationData")
$appDataPath = Join-Path $appDataRoot 'Turtle'
$filePath   = Join-Path $appDataPath 'Turtle.raster.html'
$null = New-Item -ItemType File -Force -Path $filePath -Value (
    $pngRasterizer -join [Environment]::NewLine
)
# $pngRasterizer &gt; $filePath

$headlessArguments = @(
    '--headless', # run in headless mode
    '--dump-dom', # dump the DOM to stdout
    '--disable-gpu', # disable GPU acceleration
    '--no-sandbox' # disable the sandbox if running in CI/CD            
)

$chromeOutput = &amp; $chromiumCommand @headlessArguments "$filePath" | Out-String 
if ($chromeOutput -match '&lt;img\ssrc="data:image/\w+;base64,(?&lt;b64&gt;[^"]+)') {
    ,[Convert]::FromBase64String($matches.b64)
}

                    </GetScriptBlock>
      </ScriptProperty>
      <ScriptProperty>
        <Name>Keyframe</Name>
        <GetScriptBlock>
                        &lt;#
.SYNOPSIS
    Gets Turtle keyframes
.DESCRIPTION
    Gets CSS Keyframes animations associated with the Turtle.

    Keyframes are stored as a dictionary of dictionaries.

    Each key is the name of the keyframe.
    
    Each nested dictionary is the keyframe at a given percentage.
.EXAMPLE
    turtle keyframe ([Ordered]@{
        'slide-in' = [Ordered]@{
            from = [Ordered]@{
                translate = "-150vw 0"
                scale = "200% 1"            
            }
            to = [Ordered]@{
                translate = "0 0" 
                scale = "100% 1"
            }
        }
    }) keyframe
.LINK
    https://MrPowerShell.com/CSS/Keyframes
#&gt;
if (-not $this.'.Keyframes') {
    $this | Add-Member NoteProperty '.Keyframes' ([Ordered]@{}) -Force
}
return $this.'.Keyframes'

                    </GetScriptBlock>
        <SetScriptBlock>
                        &lt;#
.SYNOPSIS
    Sets Turtle Keyframes
.DESCRIPTION
    Sets CSS Keyframes associated with a Turtle.
.EXAMPLE
    turtle square 42 fill '#4488ff' stroke '#224488' keyframe ([Ordered]@{
        'wiggle3d' = [Ordered]@{
            '0%,100%' = [Ordered]@{
                transform = "rotateX(-3deg) rotateY(-3deg) rotateZ(-3deg)"            
            }
            '50%' = [Ordered]@{
                transform = "rotateX(3deg) rotateY(3deg) rotateZ(3deg)"
            }
        }
    }) pathclass wiggle3d save ./wiggleSquare.svg 
#&gt;
param(
[PSObject]
$Keyframe
)

$keyframes = $this.Keyframe
if ($Keyframe -is [Collections.IDictionary]) {
    foreach ($key in $keyframe.Keys) {
        $keyframes[$key] = $Keyframe[$key]
    }
}

                    </SetScriptBlock>
      </ScriptProperty>
      <ScriptProperty>
        <Name>Link</Name>
        <GetScriptBlock>
                        &lt;#
.SYNOPSIS
    Gets a Turtle's link
.DESCRIPTION
    Gets a link reference (href) associated with the turtle.

    If one is present, this will nest the turtle inside of an &lt;a&gt; element
.EXAMPLE
    turtle link https://psturtle.com/ link

#&gt;
$this.'.link'

                    </GetScriptBlock>
        <SetScriptBlock>
                        &lt;#
.SYNOPSIS
    Sets a Turtle's link
.DESCRIPTION
    Sets a link reference (`href`) associated with the turtle.

    If one is present, this will nest the turtle inside of an anchor `&lt;a&gt;` element
.EXAMPLE
    turtle link https://psturtle.com/
#&gt;
param(
[string]
$Link
)

$this | Add-Member NoteProperty '.Link' $link -Force

                    </SetScriptBlock>
      </ScriptProperty>
      <ScriptProperty>
        <Name>Marker</Name>
        <GetScriptBlock>
                        &lt;#
.SYNOPSIS
    Gets the turtle as a Marker
.DESCRIPTION
    Gets the Turtle as a `&lt;marker&gt;`, which can mark points on another shape.
.EXAMPLE
    turtle viewbox 200 teleport 0 100 forward 100 markerEnd (
        turtle viewbox 10 rotate -90 polygon 10 3 fill context-fill stroke context-stroke
    ) strokewidth '3%' fill currentColor save ./marker.svg
.LINK
    https://developer.mozilla.org/en-US/docs/Web/SVG/Reference/Element/marker
#&gt;
[OutputType([xml])]
param()

# The default settings for markers
$markerAttributes = [Ordered]@{
    id="$($this.id)-marker"
    viewBox="$($this.ViewBox)"
    orient='auto-start-reverse'
    refX=$this.Width/2
    refY=$this.Height/2
    markerWidth=5 
    marketHeight=5
}
# Marker attributes can exist in .Attribute or .SVGAttribute
$prefix = [Regex]::new('^/?marker/', 'IgnoreCase')
foreach ($collection in $this.Attribute, $this.SVGAttribute) {
    foreach ($key in $collection.Keys) {
        if ($key -notmatch $prefix) { continue }
        $markerAttributes[$key -replace $prefix] = $collection[$key]
    }
}

# Create a marker XML.
[xml]@(
    "&lt;marker$(
    foreach ($key in $markerAttributes.Keys) {
        " $key='$($markerAttributes[$key])'"
    }
)&gt;"
    $this.SVG.SVG.InnerXML
"&lt;/marker&gt;"
)

                    </GetScriptBlock>
      </ScriptProperty>
      <ScriptProperty>
        <Name>MarkerEnd</Name>
        <GetScriptBlock>
                        &lt;#
.SYNOPSIS
    Gets a Turtle's end marker
.DESCRIPTION
    Gets the end marker used on the line drawn by the turtle
.EXAMPLE
    turtle viewbox 200 teleport 0 100 forward 100 markerEnd (
        turtle viewbox 10 rotate -90 polygon 10 3 # fill context-fill stroke context-stroke
    ) fill '#4488ff' stroke '#224488' strokewidth '3%' save ./marker.svg
#&gt;
return $this.PathAttribute['marker-end']

                    </GetScriptBlock>
        <SetScriptBlock>
                        &lt;#
.SYNOPSIS
    Sets the end marker
.DESCRIPTION
    Sets the end marker used on the line drawn by the turtle.

    If this is set to a string without spaces, it will be be treated as an identifier.
.EXAMPLE
    turtle viewbox 200 teleport 0 100 forward 100 markerEnd (
        turtle viewbox 10 rotate -90 polygon 10 3 # fill context-fill stroke context-stroke
    ) fill '#4488ff' stroke '#224488' strokewidth '3%' save ./marker.svg
.EXAMPLE
    turtle viewbox 200 teleport 0 100 forward 100 markerEnd (
        turtle viewbox 20 rotate -90 polygon 10 3 morph @(
            turtle rotate -90 polygon 20 3
            turtle rotate -90 polygon 20 3
        )
    ) strokewidth '3%' save ./marker.svg
#&gt;
param($Value)

$attributeValue = 
    if ($value -is [string]) {
        if ($value -notmatch '\s' -and $value -notmatch '^url') {
            $Value = "url(`"$Value`")"
        } else {
            $value
        }
    }
    else {
        if ($value.pstypenames -contains 'Turtle') {
            $Value.id += "-end"
            $this.Defines+=$Value.Marker.OuterXml
            "url(#$($value.id)-marker)"
        }
    }

$this.PathAttribute['marker-end'] = $attributeValue


                    </SetScriptBlock>
      </ScriptProperty>
      <ScriptProperty>
        <Name>MarkerMiddle</Name>
        <GetScriptBlock>
                        &lt;#
.SYNOPSIS
    Gets a Turtle's middle marker
.DESCRIPTION
    Gets the middle marker used on the line drawn by the turtle.

    This marker will be drawn on all vertices that are not the start or the end.
.EXAMPLE
    turtle viewbox 200 start 10 200 rotate -60 @(
        'forward',42,'rotate',30,'forward',42,'rotate',-30 * 4
    ) markerMiddle (
        turtle circle 10 fill red 
    ) strokewidth '3%' save ./marker.svg
#&gt;
return $this.PathAttribute['marker-mid']

                    </GetScriptBlock>
        <SetScriptBlock>
                        &lt;#
.SYNOPSIS
    Sets the middle marker
.DESCRIPTION
    Sets the middle marker used on the line drawn by the turtle.

    If this is set to a string without spaces, it will be be treated as an identifier.
.EXAMPLE
    turtle viewbox 200 start 10 200 rotate -60 @(
        'forward',42,'rotate',30,'forward',42,'rotate',-30 * 4
    ) markerMiddle (
        turtle circle 10 fill red 
    ) strokewidth '3%' save ./marker.svg
#&gt;
param($Value)

$attributeValue = 
    if ($value -is [string]) {
        if ($value -notmatch '\s' -and $value -notmatch '^url') {
            $Value = "url(`"$Value`")"
        } else {
            $value
        }
    }
    else {
        if ($value.pstypenames -contains 'Turtle') {
            $Value.id += "-mid"
            $this.Defines+=$Value.Marker.OuterXml
            "url(#$($value.id)-marker)"
        }
    }

$this.PathAttribute['marker-mid'] = $attributeValue


                    </SetScriptBlock>
      </ScriptProperty>
      <ScriptProperty>
        <Name>MarkerStart</Name>
        <GetScriptBlock>
                        &lt;#
.SYNOPSIS
    Gets a Turtle's start marker
.DESCRIPTION
    Gets the start marker used on the line drawn by the turtle
.EXAMPLE
    turtle viewbox 200 start 50 50 rotate 45 forward 100 markerStart (
        turtle rotate -90 turtleMonotile -42 fill context-fill stroke context-stroke
    ) fill 'currentColor' strokewidth '3%' save ./marker.svg
.EXAMPLE
    turtle viewbox 200 start 50 50 rotate 45 forward 100 markerStart (
        turtle rotate -90 polygon 42 3 fill context-fill stroke context-stroke
    ) fill 'currentColor' strokewidth '3%' save ./marker.svg
#&gt;
return $this.PathAttribute['marker-start']

                    </GetScriptBlock>
        <SetScriptBlock>
                        &lt;#
.SYNOPSIS
    Sets the start marker
.DESCRIPTION
    Sets the start marker used on the line drawn by the turtle.

    If this is set to a string without spaces, it will be be treated as an identifier.
.EXAMPLE
    turtle viewbox 200 start 50 100 rotate 45 forward 100 markerEnd (
        turtle rotate -90 polygon 10 3 fill context-fill stroke context-stroke
    ) fill '#4488ff' stroke '#224488' strokewidth '3%' save ./marker.svg
.EXAMPLE
    turtle viewbox 200 teleport 50 100 forward 100 markerEnd (
        turtle viewbox 20 rotate -90 polygon 10 3 morph @(
            turtle rotate -90 polygon 20 3
            turtle rotate -90 polygon 20 3
        )
    ) strokewidth '3%' save ./marker.svg
#&gt;
param($Value)

$attributeValue = 
    if ($value -is [string]) {
        if ($value -notmatch '\s' -and $value -notmatch '^url') {
            $Value = "url(`"$Value`")"
        } else {
            $value
        }
    }
    else {
        if ($value.pstypenames -contains 'Turtle') {
            $Value.id += "-start"
            $this.Defines+=$Value.Marker.OuterXml
            "url(#$($value.id)-marker)"
        }
    }

$this.PathAttribute['marker-start'] = $attributeValue


                    </SetScriptBlock>
      </ScriptProperty>
      <ScriptProperty>
        <Name>Mask</Name>
        <GetScriptBlock>
                        &lt;#
.SYNOPSIS
    Gets a Turtle's mask
.DESCRIPTION
    Gets a Turtle as an image mask.

    Everything under a white pixel will be visible.

    Everything under a black pixel will be invisible.
.EXAMPLE
    # Masks will autoscale to the object bounding box by default
    # Make sure to leave a hole.
    turtle defines @( 
        turtle id smallsquare width 84 height 84 @(
        ) teleport 21 21 square 42 @(
        ) fill black backgroundcolor white mask 
    ) square 84 fill '#4488ff' stroke '#224488' pathattribute @{
        mask='url(#smallsquare-mask)'
    } save ./square-mask.svg
.EXAMPLE
    # Masks can contain morphing
    turtle defines @( 
        turtle id smallsquare viewbox 84 @(
            'fill','black'
            'backgroundcolor','white'
        ) morph @(
            turtle teleport 21 21 square 42
            turtle teleport 41.5 41.5 square 1
            turtle teleport 21 21 square 42
        ) duration '00:00:01.68' mask 
    ) square 840 fill '#050506ff' stroke '#224488' pathattribute @{
        mask='url(#smallsquare-mask)'
    } save ./square-mask-morph.svg
.LINK
    https://developer.mozilla.org/en-US/docs/Web/SVG/Reference/Element/mask
#&gt;
[OutputType([xml])]
param()

$keyPattern = '^mask/'
$defaultId  = "$($this.Id)-mask" 
# Gather the mask attributes, and default the ID (the only attribute we actually need)
$maskAttributes = [Ordered]@{id=$defaultId}
# Attributes can exist in .SVGAttribute or .Attribute
foreach ($collectionName in 'SVGAttribute','Attribute') {
    # as long as they start with mask/
    # (slashes are not valid attribute names, so this can denote a target name or type)
    foreach ($key in $this.$collectionName.Keys -match $keyPattern) {
        $maskAttributes[$key -replace $keyPattern] = $this.$collectionName[$key]
    }
}

# Create an attribute declaration
$maskAttributes = @(foreach ($attributeName in $maskAttributes.Keys) {
    "$($attributeName)='$(
        [Web.HttpUtility]::HtmlAttributeEncode($maskAttributes[$attributeName])
    )'"
}) -join ' '

# Declare the mask segments
$segments = @(
"&lt;mask $maskAttributes&gt;"
    $this.SVG.OuterXml -replace '\&lt;\?[^\&gt;]+\&gt;'
"&lt;/mask&gt;"
)
# join them and cast to XML.
[xml]($segments -join '')
                    </GetScriptBlock>
      </ScriptProperty>
      <ScriptProperty>
        <Name>Maximum</Name>
        <GetScriptBlock>
                        &lt;#
.SYNOPSIS
    Gets the turtle's highest point.
.DESCRIPTION
    Gets the maximum point vector visited by the turtle.

    This would the highest point that the turtle has been.
#&gt;
[OutputType([Numerics.Vector2])]
param()
if (-not $this.'.Maximum') {
    $this | Add-Member NoteProperty '.Maximum' ([Numerics.Vector2]::new(0,0)) -Force
}

return $this.'.Maximum'

                    </GetScriptBlock>
      </ScriptProperty>
      <ScriptProperty>
        <Name>Minimum</Name>
        <GetScriptBlock>
                        &lt;#
.SYNOPSIS
    Gets a Turtle's lowest point
.DESCRIPTION
    Gets the minimum vector for this turtle.  
    
    This would the lowest point that the turtle has visted.
#&gt;
[OutputType([Numerics.Vector2])]
param()
if (-not $this.'.Minimum') {
    $this | Add-Member NoteProperty '.Minimum' ([Numerics.Vector2]::new(0,0)) -Force
}

return $this.'.Minimum'
                    </GetScriptBlock>
      </ScriptProperty>
      <ScriptProperty>
        <Name>OffsetPath</Name>
        <GetScriptBlock>
                        &lt;#
.SYNOPSIS
    Gets the Turtle as an OffsetPath
.DESCRIPTION
    Gets the Turtle as an offset path.
.LINK
    https://developer.mozilla.org/en-US/docs/Web/CSS/offset-path
#&gt;
param()
"offset-path: path('$($this.PathData)');"
                    </GetScriptBlock>
      </ScriptProperty>
      <ScriptProperty>
        <Name>Opacity</Name>
        <GetScriptBlock>
                        &lt;#
.SYNOPSIS
    Gets the turtle opacity
.DESCRIPTION
    Gets the opacity of the turtle path.
#&gt;
if (-not $this.'.PathAttribute') {
    $this | Add-Member -MemberType NoteProperty -Name '.PathAttribute' -Value ([Ordered]@{}) -Force
}
if ($this.'.PathAttribute'.'opacity') {
    return $this.'.PathAttribute'.'opacity'
} else {
    return 1.0
}
                    </GetScriptBlock>
        <SetScriptBlock>
                        &lt;#
.SYNOPSIS
    Sets the opacity
.DESCRIPTION
    Sets the opacity of the path
.EXAMPLE
    turtle forward 100 opacity 0.5 save ./dimLine.svg
#&gt;
param(
[double]
$Opacity = 'nonzero'
)

$this.PathAttribute = [Ordered]@{'opacity' = $Opacity}

                    </SetScriptBlock>
      </ScriptProperty>
      <ScriptProperty>
        <Name>PathAnimation</Name>
        <GetScriptBlock>
                        if ($this.'.PathAnimation') {
    return $this.'.PathAnimation'
}

                    </GetScriptBlock>
        <SetScriptBlock>
                        &lt;#
.SYNOPSIS
    Sets the Turtle Path Animation
.DESCRIPTION
    Sets an animation for the Turtle path.
.EXAMPLE
    turtle flower PathAnimation ([Ordered]@{
        attributeName = 'fill'   ; values = "#4488ff;#224488;#4488ff" ; repeatCount = 'indefinite'; dur = "4.2s" # ; additive = 'sum'
    }, [Ordered]@{
        attributeName = 'stroke'   ; values = "#224488;#4488ff;#224488" ; repeatCount = 'indefinite'; dur = "2.1s" # ; additive = 'sum'
    }, [Ordered]@{
        type = 'rotate'   ; values = 0, 360 ;repeatCount = 'indefinite'; dur = "41s"
    }) save ./AnimatedFlower.svg
#&gt;
param(
# The path animation object.
# This may be a string containing animation XML, XML, or a dictionary containing animation settings.
[PSObject]
$PathAnimation
)

$newAnimation = @(foreach ($animation in $PathAnimation) {
    if ($animation -is [Collections.IDictionary]) {
        $animationCopy = [Ordered]@{} + $animation
        if (-not $animationCopy['attributeType']) {
            $animationCopy['attributeType'] = 'XML'
        }
        if (-not $animationCopy['attributeName']) {
            $animationCopy['attributeName'] = 'transform'
        }
        if ($animationCopy.values -is [object[]]) {
            $animationCopy['values'] = $animationCopy['values'] -join ';'
        }

        $elementName = 'animate'
        if ($animationCopy['attributeName'] -eq 'transform') {
            $elementName = 'animateTransform'
        }


        if (-not $animationCopy['dur'] -and $this.Duration) {
            $animationCopy['dur'] = "$($this.Duration.TotalSeconds)s"
        }
        
        "&lt;$elementName $(
            @(foreach ($key in $animationCopy.Keys) {
                " $key='$([Web.HttpUtility]::HtmlAttributeEncode($animationCopy[$key]))'"
            }) -join ''
        )/&gt;"
    }
    if ($animation -is [string]) {
        $animation
    }
    if ($animation.OuterXml) {
        $animation.OuterXml
    }
})

if ($this.PathAnimation) {
    $newAnimation = @($this.PathAnimation) + $newAnimation
}
$this | Add-Member -MemberType NoteProperty -Force -Name '.PathAnimation' -Value $newAnimation




                    </SetScriptBlock>
      </ScriptProperty>
      <ScriptProperty>
        <Name>PathAttribute</Name>
        <GetScriptBlock>
                        if (-not $this.'.PathAttribute') { 
    $this | Add-Member NoteProperty '.PathAttribute' ([Ordered]@{}) -Force    
}
return $this.'.PathAttribute'
                    </GetScriptBlock>
        <SetScriptBlock>
                        param(
[Collections.IDictionary]
$PathAttribute = [Ordered]@{}
)

if (-not $this.'.PathAttribute') {
    $this | Add-Member -MemberType NoteProperty -Name '.PathAttribute' -Value ([Ordered]@{}) -Force
}
foreach ($key in $PathAttribute.Keys) {
    $this.'.PathAttribute'[$key] = $PathAttribute[$key]
}
                    </SetScriptBlock>
      </ScriptProperty>
      <ScriptProperty>
        <Name>PathClass</Name>
        <GetScriptBlock>
                        if ($this.'.PathClass') { return $this.'.PathClass'}
return 'foreground-stroke'
                    </GetScriptBlock>
        <SetScriptBlock>
                        &lt;#
.SYNOPSIS
    Sets the turtle path class
.DESCRIPTION
    Sets the css classes that apply to the turtle path.

    This property will rarely be set directly, but can be handy for integrating turtle graphics into custom pages.
#&gt;
param(
$PathClass
)

$this |  Add-Member -MemberType NoteProperty -Force -Name '.PathClass' -Value @($PathClass)

                    </SetScriptBlock>
      </ScriptProperty>
      <ScriptProperty>
        <Name>PathData</Name>
        <GetScriptBlock>
                        &lt;#
.SYNOPSIS
    Gets our Turtle's path
.DESCRIPTION
    Gets the path data of this Turtle's movements.
    
    This is the shape this turtle will draw.
.NOTES
    Turtle Path data is represented as a
    [SVG path](https://developer.mozilla.org/en-US/docs/Web/SVG/Tutorials/SVG_from_scratch/Paths).
    
    This format can also be used as a [Path2D](https://developer.mozilla.org/en-US/docs/Web/API/Path2D/Path2D) in a Canvas element.

    It can also be used in WPF, where it is simply called [Path Markup](https://learn.microsoft.com/en-us/dotnet/desktop/wpf/graphics-multimedia/path-markup-syntax) 
.LINK
    https://developer.mozilla.org/en-US/docs/Web/SVG/Tutorials/SVG_from_scratch/Paths
.LINK
    https://developer.mozilla.org/en-US/docs/Web/API/Path2D/Path2D
.LINK
    https://learn.microsoft.com/en-us/dotnet/desktop/wpf/graphics-multimedia/path-markup-syntax    
#&gt;
@(
    # Let's call this trick Schrödinger's rounding.
    # We want to be able to render our shapes with a custom precision
    # but we don't want to slow down in rounding or only be able to round once.
    
    # So we can round when we ask for the path data.
    # This is a much less common request than moving the turtle forward.
    $precision = $this.Precision
    filter roundToPrecision { [Math]::Round($_, $precision)}
    
    if ($null -ne $this.Start.X -and $null -ne $this.Start.Y) {
        if ($precision) {
            "m $($this.Start.x | roundToPrecision) $($this.Start.y | roundToPrecision)"
        } else {
            "m $($this.Start.x) $($this.Start.y)"
        }
        
    }
    else {
        @("m"
        # If the viewbox has been manually set 
        if ($this.'.ViewBox') {
            0, 0 # do not adjust our starting position
        } else {
            # otherwise, translate by the minimum point.
            if ($this.Minimum.X -lt 0) {
                if ($precision) {
                    -1 * $this.Minimum.X | roundToPrecision
                } else {
                    -1 * $this.Minimum.X
                }                
            }
            else { 0 }

            if ($this.Minimum.Y -lt 0) {
                if ($precision) {
                    -1 * $this.Minimum.Y | roundToPrecision
                } else {
                    -1 * $this.Minimum.Y
                }
                
            }
            else { 0 }
        }) -join ' '
    }
    
    # Walk over our steps
    foreach ($step in
        $this.Steps -join ' ' -replace ',',' ' -split '(?=[\p{L}-[E]])' -ne ''
    ) {
        # If our precision is zero or nothing, don't round 
        if (-not $precision) {
            $step
        } else {
            # Otherwise, pick out the letter
            $step.Substring(0,1)
            # and get each digit
            $digits = $step.Substring(1) -split '\s+' -ne '' -as [double[]]
            # and round them.
            foreach ($digit in $digits) {                
                [Math]::Round($digit, $precision)
            }            
        }
    }    
) -join ' '
                    </GetScriptBlock>
      </ScriptProperty>
      <ScriptProperty>
        <Name>PathElement</Name>
        <GetScriptBlock>
                        &lt;#
.SYNOPSIS
    Gets the Turtle Path Element
.DESCRIPTION
    Gets the Path Element of a Turtle.

    This contains the path of the Turtle's motion.
.EXAMPLE
    turtle forward 42 rotate 90 forward 42 pathElement
#&gt;
[OutputType([xml])]
param()
# Set our core attributes
$coreAttributes = [Ordered]@{
    id="$($this.id)-path"
    d="$($this.PathData)"
    stroke=
        if ($this.Stroke) { $this.Stroke } 
        else { 'currentColor' }
    'stroke-width'=
        if ($this.StrokeWidth) { $this.StrokeWidth } 
        else { '0.1%' }
    fill="$($this.Fill)"
    class=$($this.PathClass -join ' ')
    'transform-origin'='50% 50%' 
}
# If someone decides to override any of these attributes, they are welcome to (at their own aesthetic risk)
foreach ($pathAttributeName in $this.PathAttribute.Keys) {
    $coreAttributes[$pathAttributeName] = $($this.PathAttribute[$pathAttributeName])
}

# Path attributes can be defined within .SVGAttribute or .Attribute
$prefix = [Regex]::new('^/?path/', 'IgnoreCase')
foreach ($collection in $this.SVGAttribute, $this.Attribute) {
    if (-not $collection) { continue }
    foreach ($key in $collection.Keys -match $prefix) {
        $coreAttributes[$attributeName -replace $prefix] = $collection[$attributeName]
    }
}

# Create the elements in an array, and cast it to XML.
[xml]@(
"&lt;path$(
    foreach ($attributeName in $coreAttributes.Keys) {
        " $attributeName='$($coreAttributes[$attributeName])'"
    }
)&gt;"
if ($this.PathAnimation) {$this.PathAnimation}
"&lt;/path&gt;"
)
                    </GetScriptBlock>
      </ScriptProperty>
      <ScriptProperty>
        <Name>PathTransform</Name>
        <GetScriptBlock>
                        &lt;#
.SYNOPSIS
    Gets any Path Transforms
.DESCRIPTION
    Gets any transforms that will apply to this Turtle's path.
#&gt;
return $this.PathAttribute['transform']
                    </GetScriptBlock>
        <SetScriptBlock>
                        &lt;#
.SYNOPSIS
    Sets Path Transforms
.DESCRIPTION
    Sets any transforms that apply to the turtle path.
.EXAMPLE
    turtle width 100 height 100 teleport 25 25 square 50 pathTransform @{skewX=45} save ./skewSquare.svg
#&gt;
param($value)
$value = $value | . { process { $_ }}
$transformString = foreach ($v in $value) {
    if ($v -is [Collections.IDictionary]) {
        foreach ($k in $v.Keys) {
            "$k($($v[$k]))"
        }
    } else {
        "$v"
    }
}


return $this.PathAttribute['transform'] = "$transformString"
                    </SetScriptBlock>
      </ScriptProperty>
      <ScriptProperty>
        <Name>Pattern</Name>
        <GetScriptBlock>
                        &lt;#
.SYNOPSIS
    Gets a Turtle Pattern
.DESCRIPTION
    Gets the current turtle as a pattern that stretches off to infinity.    
.EXAMPLE
    turtle star 42 4 | Save-Turtle "./GridPattern.svg"
.EXAMPLE
    turtle star 42 6 | Save-Turtle "./StarPattern6.svg"
.EXAMPLE
    turtle star 42 8 | Save-Turtle "./StarPattern8.svg"
.EXAMPLE
    turtle star 42 5 | Save-Turtle "./StarPattern5.svg"
.EXAMPLE
    turtle star 42 7 | Save-Turtle "./Star7Pattern.svg"
.EXAMPLE
    turtle viewbox 100 start 25 25 square 50 | Save-Turtle "./WindowPattern.svg" Pattern
.EXAMPLE
    turtle star 100 4 morph @(
        turtle star 100 4
        turtle rotate 90 star 100 4
        turtle rotate 180 star 100 4
        turtle rotate 270 star 100 4
        turtle star 100 4
    ) | Save-Turtle "./GridPatternMorph.svg"
.EXAMPLE
    turtle star 100 3 morph @(
        turtle star 100 3
        turtle rotate 90 star 100 3
        turtle rotate 180 star 100 3
        turtle rotate 270 star 100 3
        turtle star 100 3
    ) | Save-Turtle "./TriPatternMorph.svg"
.EXAMPLE
    turtle star 100 6 morph @(
        turtle star 100 6
        turtle rotate 90 star 100 6
        turtle rotate 180 star 100 6
        turtle rotate 270 star 100 6
        turtle star 100 6
    ) | Save-Turtle "./Star6PatternMorph.svg" | Show-Turtle
.EXAMPLE
    # We can use a pattern transform to scale the pattern
    turtle sierpinskiTriangle PatternTransform @{
        scale = 0.25
        rotate = 120
    } | 
        Save-Turtle "./SierpinskiTrianglePattern.svg" Pattern | 
        show-Turtle
.EXAMPLE
    # We can use pattern animations to change the pattern
    # Animations are relative to initial transforms
    turtle sierpinskiTriangle PatternTransform @{
        scale = 0.25
        rotate = 120
    } PatternAnimation ([Ordered]@{
        type = 'scale'    ; values = 1.33,0.66, 1.33 ; repeatCount = 'indefinite' ;dur = "23s"; additive = 'sum'
    }) | 
        Save-Turtle "./SierpinskiTrianglePattern.svg" Pattern | 
        Show-Turtle
#&gt;
[OutputType([xml])]
param()

# Get our viewbox
$viewBox = $this.ViewBox
# and get the width and height
$null, $null, $viewX, $viewY = $viewBox

# Initialize our core attributes.
# These may be overwritten by user request.
$coreAttributes = [Ordered]@{
    'id'                = "$($this.ID)-pattern"
    'patternUnits'      = 'userSpaceOnUse'
    'width'             = $ViewX
    'height'            = $viewY
    'transform-origin'  = '50% 50%'
}

# If we have specified any transforms
if ($this.PatternTransform) {    
    $coreAttributes."patternTransform" = 
        # Then generate a transform expression
        @(foreach ($key in $this.PatternTransform.Keys) {
            # transforms are a name, followed by parameters in paranthesis
            "$key($($this.PatternTransform[$key]))"
        }) -join ' '
}

# Pattern attributes can be defined within .SVGAttribute or .Attribute
# provided they have the appropriate prefix
$prefix = [Regex]::new('^/?pattern/', 'IgnoreCase')
# (slashes are invalid markup, and thus a fine way to target nested instances)

foreach ($collection in $this.SVGAttribute, $this.Attribute) {
    # If the connection does not exist, continue.
    if (-not $collection) { continue }
    # For each key that matches the prefix
    foreach ($key in $collection.Keys -match $prefix) {
        # add it to the attributes after stripping the prefix.
        $coreAttributes[$attributeName -replace $prefix] = $collection[$attributeName]
    }
}

$segments = @(
"&lt;svg xmlns='http://www.w3.org/2000/svg' width='100%' height='100%'&gt;"
"&lt;defs&gt;"
    "&lt;pattern$(
    foreach ($attributeName in $coreAttributes.Keys) {
        " $attributeName='$($coreAttributes[$attributeName])'"
    }
)&gt;"
        $(if ($this.PatternAnimation) { $this.PatternAnimation })
        $($this.SVG.SVG.InnerXML)
    "&lt;/pattern&gt;"
"&lt;/defs&gt;"
"&lt;rect width='10000%' height='10000%' x='-5000%' y='-5000%' fill='url(#$($this.ID)-pattern)' transform-origin='50% 50%' /&gt;"
"&lt;/svg&gt;"
) 

[xml]$segments
                    </GetScriptBlock>
      </ScriptProperty>
      <ScriptProperty>
        <Name>PatternAnimation</Name>
        <GetScriptBlock>
                        if ($this.'.PatternAnimation') {
    return $this.'.PatternAnimation'
}

                    </GetScriptBlock>
        <SetScriptBlock>
                        param(
[PSObject]
$PatternAnimation
)

$newAnimation = @(foreach ($animation in $PatternAnimation) {
    if ($animation -is [Collections.IDictionary]) {
        $animationCopy = [Ordered]@{} + $animation
        if (-not $animationCopy['attributeType']) {
            $animationCopy['attributeType'] = 'XML'
        }
        if (-not $animationCopy['attributeName']) {
            $animationCopy['attributeName'] = 'patternTransform'
        }
        if ($animationCopy.values -is [object[]]) {
            $animationCopy['values'] = $animationCopy['values'] -join ';'
        }
        
        "&lt;animateTransform $(
            @(foreach ($key in $animationCopy.Keys) {
                " $key='$([Web.HttpUtility]::HtmlAttributeEncode($animationCopy[$key]))'"
            }) -join ''
        )/&gt;"
    }
    if ($animation -is [string]) {
        $animation
    }
})

$this | Add-Member -MemberType NoteProperty -Force -Name '.PatternAnimation' -Value $newAnimation

                    </SetScriptBlock>
      </ScriptProperty>
      <ScriptProperty>
        <Name>PatternDataURL</Name>
        <GetScriptBlock>
                        &lt;#
.SYNOPSIS
    Gets the turtle pattern data URL.
.DESCRIPTION
    Gets the turtle pattern as a data URL.
    
    This can be used as an inline image in HTML, CSS, or Markdown.
#&gt;
$thisPattern = $this.Pattern
$b64 = [Convert]::ToBase64String($OutputEncoding.GetBytes($thisPattern.outerXml))
"data:image/svg+xml;base64,$b64"
                    </GetScriptBlock>
      </ScriptProperty>
      <ScriptProperty>
        <Name>PatternMask</Name>
        <GetScriptBlock>
                        &lt;#
.SYNOPSIS
    Gets a Turtle's Pattern Mask
.DESCRIPTION
    Gets the current turtle as a pattern mask.
    
    Everything under a white pixel will be visible.

    Everything under a black pixel will be invisible.
    
    This will be a mask of the turtle's `.Pattern` property, and will repeat the turtle's `.SVG` multiple times.
.EXAMPLE
    # Masks will autoscale to the object bounding box by default
    # Make sure to leave a hole.
    turtle defines @( 
        turtle id smallsquare viewbox 84 teleport 21 21 square 42 @(
            'fill','black'
            'backgroundcolor','white'
        ) patternmask 
    ) square 840 fill '#4488ff' stroke '#224488' pathattribute @{
        mask='url(#smallsquare-pattern-mask)'
    } save ./square-pattern-mask.svg
.EXAMPLE
    # Masks can contain morphing
    turtle defines @( 
        turtle id smallsquare viewbox 84 @(
            'fill','black'
            'backgroundcolor','white'
        ) morph @(
            turtle teleport 21 21 square 42
            turtle teleport 42 42 square 1
            turtle teleport 21 21 square 42
        ) duration '00:00:01.68' patternmask 
    ) square 840 fill '#4488ff' stroke '#224488' pathattribute @{
        mask='url(#smallsquare-pattern-mask)'
    } save ./square-pattern-mask-morph.svg
.LINK
    https://developer.mozilla.org/en-US/docs/Web/SVG/Reference/Element/mask
#&gt;
[OutputType([xml])]
param()
$keyPattern = '^pattern-?mask/'
$defaultId  = "$($this.Id)-pattern-mask" 
# Gather the mask attributes, and default the ID (the only attribute we actually need)
$maskAttributes = [Ordered]@{id=$defaultId}
# Attributes can exist in .SVGAttribute or .Attribute
foreach ($collectionName in 'SVGAttribute','Attribute') {
    # as long as they start with mask/
    # (slashes are not valid attribute names, so this can denote a target name or type)
    foreach ($key in $this.$collectionName.Keys -match $keyPattern) {
        $maskAttributes[$key -replace $keyPattern] = $this.$collectionName[$key]
    }
}

# Create an attribute declaration
$maskAttributes = @(foreach ($attributeName in $maskAttributes.Keys) {
    "$($attributeName)='$(
        [Web.HttpUtility]::HtmlAttributeEncode($maskAttributes[$attributeName])
    )'"
}) -join ' '

# Declare the mask segments
$segments = @(
"&lt;mask $maskAttributes&gt;"
    $this.Pattern.OuterXml -replace '\&lt;\?[^\&gt;]+\&gt;'
"&lt;/mask&gt;"
)
# join them and cast to XML.
[xml]$segments
                    </GetScriptBlock>
      </ScriptProperty>
      <ScriptProperty>
        <Name>PatternTransform</Name>
        <GetScriptBlock>
                        if ($this.'.PatternTransform') {
    return $this.'.PatternTransform'
}

                    </GetScriptBlock>
        <SetScriptBlock>
                        param(
[Collections.IDictionary]
$PatternTransform
)

$this | Add-Member -MemberType NoteProperty -Force -Name '.PatternTransform' -Value $PatternTransform
                    </SetScriptBlock>
      </ScriptProperty>
      <ScriptProperty>
        <Name>PNG</Name>
        <GetScriptBlock>
                        $chromiumNames = 'chromium','chrome'
foreach ($browserName in $chromiumNames) {
    $chromiumCommand = 
        $ExecutionContext.SessionState.InvokeCommand.GetCommand($browserName,'Application')
    if (-not $chromiumCommand) { 
        $chromiumCommand = 
            Get-Process -Name $browserName -ErrorAction Ignore | 
            Select-Object -First 1 -ExpandProperty Path
    }
    if ($chromiumCommand) { break }
}
if (-not $chromiumCommand) {
    Write-Error "No Chromium-based browser found. Please install one of: $($chromiumNames -join ', ')"
    return
}

$pngRasterizer = $this.Canvas -replace '/\*Insert-Post-Processing-Here\*/', @'
    const dataUrl = await canvas.toDataURL('image/png')
    console.log(dataUrl)
  
    const newImage = document.createElement('img')
    newImage.src = dataUrl
    document.body.appendChild(newImage)
'@


$appDataRoot = [Environment]::GetFolderPath("ApplicationData")
$appDataPath = Join-Path $appDataRoot 'Turtle'
$filePath   = Join-Path $appDataPath 'Turtle.raster.html'
$null = New-Item -ItemType File -Force -Path $filePath -Value (
    $pngRasterizer -join [Environment]::NewLine
)
# $pngRasterizer &gt; $filePath

$headlessArguments = @(
    '--headless', # run in headless mode
    '--dump-dom', # dump the DOM to stdout
    '--disable-gpu', # disable GPU acceleration
    '--no-sandbox' # disable the sandbox if running in CI/CD            
)

$chromeOutput = &amp; $chromiumCommand @headlessArguments "$filePath" | Out-String 
if ($chromeOutput -match '&lt;img\ssrc="data:image/png;base64,(?&lt;b64&gt;[^"]+)') {
    ,[Convert]::FromBase64String($matches.b64)
}

                    </GetScriptBlock>
      </ScriptProperty>
      <ScriptProperty>
        <Name>Points</Name>
        <GetScriptBlock>
                        $this.Steps -replace '[\w-[\d\.E\-]]+' -split '\s+' -ne '' -as [double[]]
                    </GetScriptBlock>
      </ScriptProperty>
      <ScriptProperty>
        <Name>Position</Name>
        <GetScriptBlock>
                        &lt;#
.SYNOPSIS
    Gets the Turtle's position
.DESCRIPTION
    Gets the current position of the turtle as a vector.
#&gt;
[OutputType([Numerics.Vector2])]
param()
if (-not $this.'.Position') {
    $this |  Add-Member -MemberType NoteProperty -Force -Name '.Position' -Value (
        [Numerics.Vector2]::new(0,0)
    )
}
return $this.'.Position'

                    </GetScriptBlock>
        <SetScriptBlock>
                        &lt;#
.SYNOPSIS
    Sets the Turtle's position
.DESCRIPTION
    Sets the position of the Turtle and updates its minimum and maximum.
    
    This should really not be done directly - the position should be updated as the Turtle moves.
.NOTES
    Changing the position outside of the turtle will probably not work how you would expect.
#&gt;
param([double[]]$xy)
# break apart the components
$x, $y = $xy
# and add a position if we do not have one.
if (-not $this.'.Position') {
    $this |  Add-Member -MemberType NoteProperty -Force -Name '.Position' -Value ([Numerics.Vector2]@{ X = 0; Y = 0 })
}
# Modify the position without creating a new object
$this.'.Position'.X += $x
$this.'.Position'.Y += $y
# And readback our new position
$posX, $posY = $this.'.Position'.X, $this.'.Position'.Y
# If we have no .Minimum
if (-not $this.'.Minimum') {
    # create one.
    $this |  Add-Member -MemberType NoteProperty -Force -Name '.Minimum' -Value ([Numerics.Vector2]@{ X = 0; Y = 0 })
}

# Then check if we need to update our minimum point.
if ($posX -lt $this.'.Minimum'.X) {
    $this.'.Minimum'.X = $posX
}
if ($posY -lt $this.'.Minimum'.Y) {
    $this.'.Minimum'.Y = $posY
}

# If we have no .Maximum
if (-not $this.'.Maximum') {
    # create one.
    $this |  Add-Member -MemberType NoteProperty -Force -Name '.Maximum' -Value ([Numerics.Vector2]@{ X = 0; Y = 0 })
}

# Then update our maximum point
if ($posX -gt $this.'.Maximum'.X) {
    $this.'.Maximum'.X = $posX
}
if ($posY -gt $this.'.Maximum'.Y) {
    $this.'.Maximum'.Y = $posY
}
                    </SetScriptBlock>
      </ScriptProperty>
      <ScriptProperty>
        <Name>Precision</Name>
        <GetScriptBlock>
                        &lt;#
.SYNOPSIS
    Gets Turtle Precision
.DESCRIPTION
    Gets the rounding precision for the turtle.

    Any move the turtle makes will be rounded by this number of digits.

    Paths with more rounding may be more accurate at extremly high resolutions.
    
    They will have difficulty rendering stepwise animations and take up more file space per point.

    The default value for `Precision` is currently `6`
#&gt;
if (-not $this.'.Precision') {
    $this | Add-Member NoteProperty '.Precision' 6 -Force
}
return $this.'.Precision'

                    </GetScriptBlock>
        <SetScriptBlock>
                        &lt;#
.SYNOPSIS
    Sets the Turtle's Precision
.DESCRIPTION
    Sets the level of precision a turtle should use for rounding.

    This is the number of digits a value will be rounded to.
    
    Lower precision will result in smaller filesizes, and a much better chance of stepwise animations working properly.

    Higher precision will result in large filesizes and will occassionally cause stepwise animations to get stuck.
#&gt;
param(
# The number of decimal places used in rounding.
[ValidateRange(1,28)]
[int]
$Precision = 6
)

$this | Add-Member NoteProperty '.Precision' $Precision -Force



                    </SetScriptBlock>
      </ScriptProperty>
      <ScriptProperty>
        <Name>ScriptBlock</Name>
        <GetScriptBlock>
                        &lt;#
.SYNOPSIS
    Get the Turtle's ScriptBlock
.DESCRIPTION
    Gets the ScriptBlock used to create the turtle.

    All steps will become a fluent pipeline.
.EXAMPLE
    turtle SierpinskiTriangle 42 4 scriptBlock
#&gt;
[OutputType([ScriptBlock])]
param()
# Join all of our previous command extents into a fluent pipeline
$stringifiedScript = $this.Commands.Extent -join 
    (' |' + [Environment]::NewLine + '    ') -replace # and then replace any unescaped use of 'ScriptBlock' or 'DataBlock'
    "(?&lt;!\[)(?&gt;$(
        'ScriptBlock', 'DataBlock' -join '|'
    ))(?!\])\s{0,}"
[ScriptBlock]::Create($stringifiedScript)

                    </GetScriptBlock>
      </ScriptProperty>
      <ScriptProperty>
        <Name>Stack</Name>
        <GetScriptBlock>
                        if ($null -ne $this.'.Stack'.Count) {
    $this | Add-Member NoteProperty '.Stack' ([Collections.Stack]::new()) -Force
}
$this.'.Stack'

                    </GetScriptBlock>
      </ScriptProperty>
      <ScriptProperty>
        <Name>Start</Name>
        <GetScriptBlock>
                        &lt;#
.SYNOPSIS
    Gets the Start Vector a Turtle
.DESCRIPTION
    Gets the starting vector for a Turtle.

    Setting this value avoids an automatic calculation of a starting position.
.EXAMPLE
    turtle width 300 height 300 start 50 square 200 start
#&gt;
return $this.'.Start'

                    </GetScriptBlock>
        <SetScriptBlock>
                        &lt;#
.SYNOPSIS
    Sets the Start Vector for a Turtle
.DESCRIPTION
    Sets the starting vector for a Turtle.

    This avoids an automatic calculation of a starting position
.EXAMPLE
    turtle width 300 height 300 start 50 square 200
#&gt;
param(
[PSObject]
$Value
)


$aNewStart = 
    if ($value -is [object[]] -and $value -as [float[]]) {
        [Numerics.Vector2]::new($value -as [float[]])
    } elseif ($value.GetType -and $value.GetType().IsPrimitive) {
        [Numerics.Vector2]::new($value,$value)
    } elseif ($value.X -and $value.Y) {
        [Numerics.Vector2]::new($value.X,$value.Y)
    }

if ($aNewStart) {
    $this | Add-Member NoteProperty '.Start' $aNewStart -Force
}




                    </SetScriptBlock>
      </ScriptProperty>
      <ScriptProperty>
        <Name>Steps</Name>
        <GetScriptBlock>
                        if (-not $this.'.Steps') {   
    $this.psobject.properties.add(
        [psnoteproperty]::new(
            '.Steps', [Collections.Generic.List[string]]::new()
        ), $false
    )    
}
return ,$this.'.Steps'

                    </GetScriptBlock>
        <SetScriptBlock>
                        &lt;#
.SYNOPSIS
    Sets the steps of the turtle.
.DESCRIPTION
    Sets the steps of the turtle to the specified array of strings.

    This property will rarely be set directly, but will be updated every time the turtle moves.    
#&gt;
param(
[string[]]
$Steps
)

$currentSteps = $this.Steps
foreach ($step in $steps) {
    $currentSteps.Add($step)
}


                    </SetScriptBlock>
      </ScriptProperty>
      <ScriptProperty>
        <Name>Stroke</Name>
        <GetScriptBlock>
                        if ($this.'.Stroke') {
    return $this.'.Stroke'
} else {
    return 'currentcolor'
}
                    </GetScriptBlock>
        <SetScriptBlock>
                        param([string]$value)

$this | Add-Member -MemberType NoteProperty -Force -Name '.Stroke' -Value $value
                    </SetScriptBlock>
      </ScriptProperty>
      <ScriptProperty>
        <Name>StrokeWidth</Name>
        <GetScriptBlock>
                        if ($this.'.StrokeWidth') {
    return $this.'.StrokeWidth'
} else {
    return '0.25%'
}
                    </GetScriptBlock>
        <SetScriptBlock>
                        param([string]$value)

$this | Add-Member -MemberType NoteProperty -Force -Name '.StrokeWidth' -Value $value
                    </SetScriptBlock>
      </ScriptProperty>
      <ScriptProperty>
        <Name>Style</Name>
        <GetScriptBlock>
                        &lt;#
.SYNOPSIS
    Gets a Turtle's Style
.DESCRIPTION
    Gets any CSS styles associated with the Turtle.

    These styles will be declared in a `&lt;style&gt;` element, just beneath a Turtle's `&lt;svg&gt;`
.EXAMPLE
    turtle style '.myClass { color: #4488ff}' style
#&gt;
param()

if (-not $this.'.style') {
    $this | Add-Member NoteProperty '.style' @() -Force
}

return $this.'.style'
                    </GetScriptBlock>
        <SetScriptBlock>
                        &lt;#
.SYNOPSIS
    Sets a Turtle's Style
.DESCRIPTION
    Sets any CSS styles associated with the Turtle.

    These styles will be declared in a `&lt;style&gt;` element, just beneath a Turtle's `&lt;svg&gt;`
.EXAMPLE
    turtle style '.myClass { color: #4488ff}' style
#&gt;
param(
[PSObject]
$Style
)

$styleList = $this.Style
$styleList += $style
$this | Add-Member NoteProperty '.style' $styleList -Force 

                    </SetScriptBlock>
      </ScriptProperty>
      <ScriptProperty>
        <Name>SVG</Name>
        <GetScriptBlock>
                        &lt;#
.SYNOPSIS
    The Turtle's SVG
.DESCRIPTION
    Gets this turtle and any nested turtles as a single Scalable Vector Graphic.
#&gt;
[OutputType([xml])]
param()

$svgAttributes = [Ordered]@{
    xmlns='http://www.w3.org/2000/svg'
    viewBox="$($this.ViewBox)"
    'transform-origin'='50% 50%'
    width='100%'
    height='100%'
}

# If the viewbox would have zero width or height
if ($this.ViewBox[-1] -eq 0 -or $this.ViewBox[-2] -eq 0) {
    # It's not much of a viewbox at all, and we will omit the attribute.
    $svgAttributes.Remove('viewBox')
}

# Any explicitly provided attributes should override any automatic attributes.

# These can come from .Attribute
foreach ($key in $this.Attribute.Keys) {
    if ($key -match '^svg/') { # (as long as they start with `svg/`)
        $svgAttributes[$key -replace '^svg/'] = $this.Attribute[$key]
    }
}

# They can also come from `.SVGAttribute`
foreach ($key in $this.SVGAttribute.Keys) {
    $svgAttributes[$key] = $this.SVGAttribute[$key]
}

$svgElement = @(
"&lt;svg $(@(foreach ($attributeName in $svgAttributes.Keys) {
    if ($attributeName -match '/') { continue }
    " $attributeName='$($svgAttributes[$attributeName])'"
}) -join '')&gt;"
    # Declare any definitions, like markers or gradients.
    if ($this.Defines) {
        "&lt;defs&gt;"
            $this.Defines
        "&lt;/defs&gt;"
    }
    
    if ($this.Keyframe.Count -or $this.Style) {        
        $keyframe = $this.Keyframe
        "&lt;style&gt;"
        @(foreach ($keyframeName in $keyframe.Keys) {
            $keyframeKeyframes = $keyframe[$keyframeName]
            "@keyframes $keyframeName {"
            foreach ($percent in $keyframeKeyframes.Keys) {
                "  $percent {"
                $props = $keyframeKeyframes[$percent]
                foreach ($prop in $props.Keys) {
                    $value = $props.$prop
                    "    ${prop}: $value;"
                }
                "  }"
            }
            "}"
            ".$keyframeName {"
            "    animation-name: $keyframeName;"
            "    animation-duration: $($this.Duration.TotalSeconds)s;"
            "    animation-iteration-count: infinite;"
            "}"
        }) -join [Environment]::NewLine
        if ($this.Style) {
            "$($this.Style -join (';' + [Environment]::NewLine))"
        }
        "&lt;/style&gt;"
    }

    # Declare any SVG animations
    if ($this.SVGAnimation) {$this.SVGAnimation}
    if ($this.BackgroundColor) {
        "&lt;rect width='10000%' height='10000%' x='-5000%' y='-5000%' fill='$($this.BackgroundColor)' transform-origin='50% 50%' /&gt;"
    }
    if ($this.Link) {
        "&lt;a href='$($this.Link)'&gt;"
    }
    # Output our own path
    $this.PathElement.OuterXml
    # Followed by any text elements
    $this.TextElement.OuterXml    

    # If the turtle has children
    $children = @(foreach ($turtleName in $this.Turtles.Keys) {
        # make sure they're actually turtles
        if ($this.Turtles[$turtleName].pstypenames -notcontains 'Turtle') { continue }
        # and then set their IDs
        $childTurtle = $this.Turtles[$turtleName]
        $childTurtle.ID = "$($this.ID)-$turtleName"
        $childTurtle
    })
    # If we have any children
    if ($children) {
        # put them in a group containing their children
        "&lt;g id='$($this.ID)-children'&gt;"            
            foreach ($child in $children) {
                # and ask for this child's inner XML
                # (which would contain any of its children) 
                # (and their children's children)
                # and so on.
                $child.SVG.SVG.InnerXML                
            }
        "&lt;/g&gt;"
    }
    if ($this.Link) {
        "&lt;/a&gt;"
    }
"&lt;/svg&gt;"
)
[xml]$svgElement
                    </GetScriptBlock>
      </ScriptProperty>
      <ScriptProperty>
        <Name>SVGAnimation</Name>
        <GetScriptBlock>
                        if ($this.'.SVGAnimation') {
    return $this.'.SVGAnimation'
}

                    </GetScriptBlock>
        <SetScriptBlock>
                        &lt;#
.SYNOPSIS
    Sets the Turtle SVG Animation
.DESCRIPTION
    Sets an animation for the Turtle's SVG.
.EXAMPLE
    turtle flower SVGAnimation ([Ordered]@{
        attributeName = 'fill'   ; values = "#4488ff;#224488;#4488ff" ; repeatCount = 'indefinite'; dur = "4.2s" # ; additive = 'sum'
    }, [Ordered]@{
        attributeName = 'stroke'   ; values = "#224488;#4488ff;#224488" ; repeatCount = 'indefinite'; dur = "2.1s" # ; additive = 'sum'
    }, [Ordered]@{
        type = 'rotate'   ; values = 0, 360 ;repeatCount = 'indefinite'; dur = "41s"
    }) save ./AnimatedFlower.svg
#&gt;
param(
# The path animation object.
# This may be a string containing animation XML, XML, or a dictionary containing animation settings.
[PSObject]
$SVGAnimation
)

$newAnimation = @(foreach ($animation in $SVGAnimation) {
    if ($animation -is [Collections.IDictionary]) {
        $animationCopy = [Ordered]@{} + $animation
        if (-not $animationCopy['attributeType']) {
            $animationCopy['attributeType'] = 'XML'
        }
        if (-not $animationCopy['attributeName']) {
            $animationCopy['attributeName'] = 'transform'
        }
        if ($animationCopy.values -is [object[]]) {
            $animationCopy['values'] = $animationCopy['values'] -join ';'
        }

        $elementName = 'animate'
        if ($animationCopy['attributeName'] -eq 'transform') {
            $elementName = 'animateTransform'
        }


        if (-not $animationCopy['dur'] -and $this.Duration) {
            $animationCopy['dur'] = "$($this.Duration.TotalSeconds)s"
        }
        
        "&lt;$elementName $(
            @(foreach ($key in $animationCopy.Keys) {
                " $key='$([Web.HttpUtility]::HtmlAttributeEncode($animationCopy[$key]))'"
            }) -join ''
        )/&gt;"
    }
    if ($animation -is [string]) {
        $animation
    }
    if ($animation.OuterXml) {
        $animation.OuterXml
    }
})

$this | Add-Member -MemberType NoteProperty -Force -Name '.SVGAnimation' -Value $newAnimation

                    </SetScriptBlock>
      </ScriptProperty>
      <ScriptProperty>
        <Name>SVGAttribute</Name>
        <GetScriptBlock>
                        if (-not $this.'.SVGAttribute') { 
    $this | Add-Member NoteProperty '.SVGAttribute' ([Ordered]@{}) -Force    
}
return $this.'.SVGAttribute'
                    </GetScriptBlock>
        <SetScriptBlock>
                        param(
[Collections.IDictionary]
$SVGAttribute = [Ordered]@{}
)

if (-not $this.'.SVGAttribute') {
    $this | Add-Member -MemberType NoteProperty -Name '.SVGAttribute' -Value ([Ordered]@{}) -Force
}
foreach ($key in $SVGAttribute.Keys) {
    $this.'.SVGAttribute'[$key] = $SVGAttribute[$key]
}
                    </SetScriptBlock>
      </ScriptProperty>
      <ScriptProperty>
        <Name>Symbol</Name>
        <GetScriptBlock>
                        &lt;#
.SYNOPSIS
    Gets the Turtle as a symbol.
.DESCRIPTION
    Returns the turtle as an SVG symbol element, which can be used in other SVG files.

    Symbols allow a shape to be scaled and reused without having the duplicate the drawing commands.

    By default, this will return a SVG defining the symbol and using it to fill the viewport.
.EXAMPLE
    Move-Turtle Flower |
        Select-Object -ExpandProperty Symbol
#&gt;
[OutputType([xml])]
param()

[xml]@(
"&lt;svg xmlns='http://www.w3.org/2000/svg' width='100%' height='100%' transform-origin='50% 50%'&gt;"
    "&lt;symbol id='$($this.ID)-symbol' viewBox='$($this.ViewBox)' transform-origin='50% 50%'&gt;"
        $($this.SVG.OuterXml)
    "&lt;/symbol&gt;"
    "&lt;use href='#$($this.ID)-symbol' width='100%' height='100%' transform-origin='50% 50%' /&gt;"
"&lt;/svg&gt;"
)
                    </GetScriptBlock>
      </ScriptProperty>
      <ScriptProperty>
        <Name>Text</Name>
        <GetScriptBlock>
                        &lt;#
.SYNOPSIS
    Gets the Turtle text
.DESCRIPTION
    Gets the text associated with the Turtle, if any exists.

#&gt;
return $this.'.Text'
                    </GetScriptBlock>
        <SetScriptBlock>
                        &lt;#
.SYNOPSIS
    Sets the Turtle text
.DESCRIPTION
    Sets the text displayed along the turtle path.

    Once this property is set, a text element will be displayed along with the turtle path.

    To display only text, please also set the path's stroke to `transparent`
#&gt;
param(
[string[]]
$Text
)

$this | Add-Member NoteProperty '.Text' -Force ($text -join ' ')

                    </SetScriptBlock>
      </ScriptProperty>
      <ScriptProperty>
        <Name>TextAnimation</Name>
        <GetScriptBlock>
                        if ($this.'.TextAnimation') {
    return $this.'.TextAnimation'
}

                    </GetScriptBlock>
        <SetScriptBlock>
                        &lt;#
.SYNOPSIS
    Sets the Turtle Text Animation
.DESCRIPTION
    Sets an animation for the Turtle path.
.EXAMPLE
    turtle rotate 90 jump 50 rotate -90 forward 100 text 'Hello World' textAnimation ([Ordered]@{
        attributeName = 'fill'   ; values = "#4488ff;#224488;#4488ff" ; repeatCount = 'indefinite'; dur = "4.2s"
    },[Ordered]@{
        attributeName = 'font-size'   ; values = "1em;1.3em;1em" ; repeatCount = 'indefinite'; dur = "4.2s"
    }) save ./textAnimation.svg
#&gt;
param(
# The text animation object.
# This may be a string containing animation XML, XML, or a dictionary containing animation settings.
[PSObject]
$TextAnimation
)

$newAnimation = @(foreach ($animation in $TextAnimation) {
    if ($animation -is [Collections.IDictionary]) {
        $animationCopy = [Ordered]@{} + $animation
        if (-not $animationCopy['attributeType']) {
            $animationCopy['attributeType'] = 'XML'
        }
        if (-not $animationCopy['attributeName']) {
            $animationCopy['attributeName'] = 'transform'
        }
        if ($animationCopy.values -is [object[]]) {
            $animationCopy['values'] = $animationCopy['values'] -join ';'
        }

        $elementName = 'animate'
        if ($animationCopy['attributeName'] -eq 'transform') {
            $elementName = 'animateTransform'
        }


        if (-not $animationCopy['dur'] -and $this.Duration) {
            $animationCopy['dur'] = "$($this.Duration.TotalSeconds)s"
        }
        
        "&lt;$elementName $(
            @(foreach ($key in $animationCopy.Keys) {
                " $key='$([Web.HttpUtility]::HtmlAttributeEncode($animationCopy[$key]))'"
            }) -join ''
        )/&gt;"
    }
    if ($animation -is [string]) {
        $animation
    }
    if ($animation.OuterXml) {
        $animation.OuterXml
    }
})

$this | Add-Member -MemberType NoteProperty -Force -Name '.TextAnimation' -Value $newAnimation

                    </SetScriptBlock>
      </ScriptProperty>
      <ScriptProperty>
        <Name>TextAttribute</Name>
        <GetScriptBlock>
                        &lt;#
.SYNOPSIS
    Gets any Text Attributes
.DESCRIPTION
    Gets any attributes associated with the Turtle text
    
#&gt;
if (-not $this.'.TextAttribute') { 
    $this | Add-Member NoteProperty '.TextAttribute' ([Ordered]@{}) -Force    
}
return $this.'.TextAttribute'
                    </GetScriptBlock>
        <SetScriptBlock>
                        &lt;#
.SYNOPSIS
    Sets text attributes
.DESCRIPTION
    Sets any attributes associated with the turtle text.

    These will become the attributes on the `&lt;text&gt;` element.
#&gt;
param(
# The text attributes.
[Collections.IDictionary]
$TextAttribute = [Ordered]@{}
)

if (-not $this.'.TextAttribute') {
    $this | Add-Member -MemberType NoteProperty -Name '.TextAttribute' -Value ([Ordered]@{}) -Force
}
foreach ($key in $TextAttribute.Keys) {
    $this.'.TextAttribute'[$key] = $TextAttribute[$key]
}
                    </SetScriptBlock>
      </ScriptProperty>
      <ScriptProperty>
        <Name>TextElement</Name>
        <GetScriptBlock>
                        &lt;#
.SYNOPSIS
    Gets a Turtle's text element
.DESCRIPTION
    Gets a Turtle's text as a SVG Text element.

    If the Turtle does not have any text, this will return nothing.

    If the Turtle has text, but no path, the text will be centered in the Turtle's viewbox.
.LINK
    https://developer.mozilla.org/en-US/docs/Web/SVG/Reference/Element/text
.EXAMPLE
    turtle text "hello world" textElement
#&gt;
[OutputType([xml])]
param()

if (-not $this.Text) { return }

$textAttributes = [Ordered]@{}

if (-not $this.Steps) {
    $textAttributes['dominant-baseline'] = 'middle'
    $textAttributes['text-anchor'] = 'middle'
    $textAttributes['x'] = '50%'
    $textAttributes['y'] = '50%'
}

foreach ($collection in 'SVGAttribute','Attribute') {
    foreach ($key in $this.$collection.Keys) {
        if ($key -match '^text/') {
            $textAttributes[$key -replace '^text/'] = $this.$collection[$key]
        }
    }
}

foreach ($key in $this.TextAttribute.Keys) {
    $textAttributes[$key] = $this.TextAttribute[$key]
}

return [xml]@(
"&lt;text id='$($this.ID)-text' $(
    foreach ($TextAttributeName in $TextAttributes.Keys) {
        " $TextAttributeName='$($TextAttributes[$TextAttributeName])'"
    }
)&gt;"
if ($this.TextAnimation) {$this.TextAnimation}
if ($this.Steps) {
    "&lt;textPath href='#$($this.id)-path'&gt;$([Security.SecurityElement]::Escape($this.Text))&lt;/textPath&gt;"
} else {
    $([Security.SecurityElement]::Escape($this.Text))
}
"&lt;/text&gt;"
)



                    </GetScriptBlock>
      </ScriptProperty>
      <ScriptProperty>
        <Name>Turtles</Name>
        <GetScriptBlock>
                        &lt;#
.SYNOPSIS
    Gets a Turtle's Turtles
.DESCRIPTION
    Gets the Turtles contained within a Turtle object.

    These turtles may also contain turtles...
    which may also contain turtles... 
    which may also contain turtles...
    which may also contain turtles...
    all the way down.
.EXAMPLE
    turtle square 42 turtles @{
        circle = turtle circle 21        
    } save ./InscribedSquare.svg
     
.EXAMPLE
    turtle square 42 turtles @{
        square = 
            turtle teleport 4 4 square 34 turtles @{
                square = turtle teleport 8 8 square 26 turtles @{
                    square = turtle teleport 8 8 square 26 turtles @{
                        square = turtle teleport 12 12 square 18 turtles @{
                            square = turtle teleport 16 16 square 10
                        }
                    }
                }
            }        
    } save ./SquaresWithinSquares.svg
#&gt;
if ($this -and -not $this.'.Turtles') {
    $this | Add-Member NoteProperty '.Turtles' ([Ordered]@{}) -Force 
}

return $this.'.Turtles'
                    </GetScriptBlock>
        <SetScriptBlock>
                        &lt;#
.SYNOPSIS
    Sets a Turtle's Turtles
.DESCRIPTION
    Sets the Turtles contained within a Turtle object.

    These turtles may also contain turtles...
    which may also contain turtles... 
    which may also contain turtles...
    which may also contain turtles...
    all the way down.
.EXAMPLE
    turtle square 42 turtles @{
        circle = turtle circle 21        
    } save ./InscribedSquare.svg     
.EXAMPLE
    turtle square 42 turtles @{
        square = 
            turtle teleport 4 4 square 34 turtles @{
                square = turtle teleport 8 8 square 26 turtles @{
                    square = turtle teleport 8 8 square 26 turtles @{
                        square = turtle teleport 12 12 square 18 turtles @{
                            square = turtle teleport 16 16 square 10
                        }
                    }
                }
            }        
    } save ./SquaresWithinSquares.svg
#&gt;
param(
[PSObject]
$Value
)

# If we don't already have a turtles dictionary
if ($this -and -not $this.'.Turtles') {
    # now is the time to create one.
    $this | Add-Member NoteProperty '.Turtles' ([Ordered]@{}) -Force 
}

# Go over each value
foreach ($v in $value) {
    # If the value was a dictionary
    if ($v -is [Collections.IDictionary]) {
        # merge it into our turtle dictionary
        foreach ($key in $v.Keys) {
            $this.'.Turtles'[$key] = $V[$key]
        }    
    } elseif ($v.pstypenames -contains 'Turtle') {
        # If it was a turtle, just add it

        # If the turtle had an ID, use it
        if ($v.ID -ne 'Turtle') {
            $this.'.Turtles'[$v.ID] = $v
        } else {
            # otherwise, provide it an auto incremented ID
            $this.'.Turtles'["Turtle$($this.'.Turtles'.Count + 1)"] = $v
        }        
    } elseif ($v -is [int]) {
        # If the provided a number, let's create that many turtles.
        # Note: the automatic placement of these turtles might be nice, and may be added in the future.
        foreach ($n in 1..([Math]::Abs($value))) {
            $this.'.Turtles'["Turtle$($this.'.Turtles'.Count + 1)"] = turtle
        }    
    }
}

return $this.'.Turtles'
                    </SetScriptBlock>
      </ScriptProperty>
      <ScriptProperty>
        <Name>ViewBox</Name>
        <GetScriptBlock>
                        if ($this.'.ViewBox') { return $this.'.ViewBox' }

$viewX = $this.Maximum.X + ($this.Minimum.X * -1)
$viewY = $this.Maximum.Y + ($this.Minimum.Y * -1)

return 0, 0, $viewX, $viewY



                    </GetScriptBlock>
        <SetScriptBlock>
                        param(
[double[]]
$viewBox
)

if ($viewBox.Length -gt 4) {
    $viewBox = $viewBox[0..3]
}
if ($viewBox.Length -lt 4) {
    if ($viewBox.Length -eq 3) {
        $viewBox = $viewBox[0], $viewBox[1], $viewBox[2],$viewBox[2]
    }
    if ($viewBox.Length -eq 2) {
        $viewBox = 0,0, $viewBox[0], $viewBox[1]
    }
    if ($viewBox.Length -eq 1) {
        $viewBox = 0,0, $viewBox[0], $viewBox[0]
    }
}

if ($viewBox[0] -eq 0 -and 
    $viewBox[1] -eq 0 -and 
    $viewBox[2] -eq 0 -and  
    $viewBox[3] -eq 0
) {
    $viewX = $this.Maximum.X + ($this.Minimum.X * -1)
    $viewY = $this.Maximum.Y + ($this.Minimum.Y * -1)
    $this.psobject.Properties.Remove('.ViewBox')
    return
}

$this | Add-Member -MemberType NoteProperty -Force -Name '.ViewBox' -Value $viewBox

                    </SetScriptBlock>
      </ScriptProperty>
      <ScriptProperty>
        <Name>WEBP</Name>
        <GetScriptBlock>
                        $chromiumNames = 'chromium','chrome'
foreach ($browserName in $chromiumNames) {
    $chromiumCommand = 
        $ExecutionContext.SessionState.InvokeCommand.GetCommand($browserName,'Application')
    if (-not $chromiumCommand) { 
        $chromiumCommand = 
            Get-Process -Name $browserName -ErrorAction Ignore | 
            Select-Object -First 1 -ExpandProperty Path
    }
    if ($chromiumCommand) { break }
}
if (-not $chromiumCommand) {
    Write-Error "No Chromium-based browser found. Please install one of: $($chromiumNames -join ', ')"
    return
}

$pngRasterizer = $this.Canvas -replace '/\*Insert-Post-Processing-Here\*/', @'
    const dataUrl = await canvas.toDataURL('image/webp')
    console.log(dataUrl)
  
    const newImage = document.createElement('img')
    newImage.src = dataUrl
    document.body.appendChild(newImage)
'@


$appDataRoot = [Environment]::GetFolderPath("ApplicationData")
$appDataPath = Join-Path $appDataRoot 'Turtle'
$filePath   = Join-Path $appDataPath 'Turtle.raster.html'
$null = New-Item -ItemType File -Force -Path $filePath -Value (
    $pngRasterizer -join [Environment]::NewLine
)
# $pngRasterizer &gt; $filePath

$headlessArguments = @(
    '--headless', # run in headless mode
    '--dump-dom', # dump the DOM to stdout
    '--disable-gpu', # disable GPU acceleration
    '--no-sandbox' # disable the sandbox if running in CI/CD            
)

$chromeOutput = &amp; $chromiumCommand @headlessArguments "$filePath" | Out-String 
if ($chromeOutput -match '&lt;img\ssrc="data:image/\w+;base64,(?&lt;b64&gt;[^"]+)') {
    ,[Convert]::FromBase64String($matches.b64)
}

                    </GetScriptBlock>
      </ScriptProperty>
      <ScriptProperty>
        <Name>Width</Name>
        <GetScriptBlock>
                        &lt;#
.SYNOPSIS
    Gets the Turtle width
.DESCRIPTION
    Gets the Turtle's ViewBox width.
.NOTES
    If this has not been set, it will be automatically computed from the distance between the minimum and maximum.
.EXAMPLE
    turtle forward 100 width
#&gt;
if ($this.'.ViewBox') { 
    return @($this.'.ViewBox')[-2]
}

$viewX = $this.Maximum.X + ($this.Minimum.X * -1)
return $viewX



                    </GetScriptBlock>
        <SetScriptBlock>
                        &lt;#
.SYNOPSIS
    Sets the turtle width
.DESCRIPTION
    Sets the Turtle viewbox width.
.NOTES
    Once set, it will no longer be automatically computed.
#&gt;
param(
# The new viewbox width.
[double]
$Width
)

$viewBox = $this.ViewBox
$this.ViewBox = $viewBox[0],$viewBox[1],$width, $viewBox[-1]

                    </SetScriptBlock>
      </ScriptProperty>
      <ScriptProperty>
        <Name>X</Name>
        <GetScriptBlock>
                        $this.Position.X
                    </GetScriptBlock>
      </ScriptProperty>
      <ScriptProperty>
        <Name>Y</Name>
        <GetScriptBlock>
                        $this.Position.Y
                    </GetScriptBlock>
      </ScriptProperty>
      <NoteProperty>
        <Name>DefaultDisplay</Name>
        <Value>Heading
Position
</Value>
      </NoteProperty>
    </Members>
  </Type>
  <Type>
    <Name>Turtle.History</Name>
    <Members>
      <MemberSet>
        <Name>PSStandardMembers</Name>
        <Members>
          <PropertySet>
            <Name>DefaultDisplayPropertySet</Name>
            <ReferencedProperties>
              <Name>Start</Name>
              <Name>End</Name>
              <Name>Delta</Name>
              <Name>Instruction</Name>
            </ReferencedProperties>
          </PropertySet>
        </Members>
      </MemberSet>
      <ScriptMethod>
        <Name>ToString</Name>
        <Script>
                        $this.Instruction

                    </Script>
      </ScriptMethod>
      <NoteProperty>
        <Name>DefaultDisplay</Name>
        <Value>Start
End
Delta
Instruction
</Value>
      </NoteProperty>
    </Members>
  </Type>
</Types>